#ifndef WRITE_CONVERSIONS_HPP
#define WRITE_CONVERSIONS_HPP

#include "phoenix_bridge/include_types.h"

#include <grpcpp/grpcpp.h>

#include <google/protobuf/descriptor.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/message.h>
#include <google/protobuf/dynamic_message.h>

#include <math.h>

#include "phoenix_bridge/ServiceStubs/Plc/Gds/IDataAccessService.grpc.pb.h"
#include "phoenix_bridge/ServiceStubs/ArpTypes.grpc.pb.h"

using grpc::Channel;
using grpc::ClientContext;
using grpc::ClientReader;
using grpc::Status;

using Arp::Type::Grpc::ObjectType;

using Arp::Plc::Gds::Services::Grpc::IDataAccessService;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceReadRequest;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceReadResponse;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceReadSingleRequest;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceReadSingleResponse;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceWriteRequest;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceWriteResponse;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceWriteSingleRequest;
using Arp::Plc::Gds::Services::Grpc::IDataAccessServiceWriteSingleResponse;

/**
 * @brief Provides templated functions to pack data from ros msg (or any basic type) into a Grpc::WriteItem
 * which can then be used to write data to the PLC.
 * The templated function specializations are generated by cog at build time for each of the types specified in the
 * parameters file.
 *
 */
namespace conversions
{
  /**
   * @brief Base template function to pack data into a WriteItem object
   * Implement template specializations for each type which has to be handled.
   * If type specilization not implemented but invoked, outputs this error msg (@todo: and also kill node)
   * @param grpc_object The write item into which data needs to be repacked
   * @param data_to_pack The ros msg data which needs to be repacked into the grpc object. Can also be base types.
   */
  template <typename T> inline
  void packWriteItem(::Arp::Plc::Gds::Services::Grpc::WriteItem* grpc_object, T data_to_pack)
  {
    (void) data_to_pack;
    (void) grpc_object;
    ROS_ERROR_STREAM_ONCE("Conversion from type " << typeid(data_to_pack).name() << " not implemented!!");
  }

  /**
   * @brief Template specialization of packWriteItem for basic double type. Used by IO services.
   * @param grpc_object
   * @param data_to_pack
   */
  template <> inline
  void packWriteItem<double>(::Arp::Plc::Gds::Services::Grpc::WriteItem* grpc_object, double data_to_pack)
  {
    grpc_object->mutable_value()->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    grpc_object->mutable_value()->set_doublevalue(data_to_pack);
  }

  /**
   * @brief Template specialization of packWriteItem for basic bool type. Used by IO services.
   * @param grpc_object
   * @param data_to_pack
   */
  template <> inline
  void packWriteItem<bool>(::Arp::Plc::Gds::Services::Grpc::WriteItem* grpc_object, bool data_to_pack)
  {
    grpc_object->mutable_value()->set_typecode(::Arp::Type::Grpc::CoreType::CT_Boolean);
    grpc_object->mutable_value()->set_boolvalue(data_to_pack);
  }

  ///
  /// The following section is generated by cog at build time. Manual edits will be lost when rebuilt.
  ///

  /*[[[cog
  import cog
  import sys
  import os

  sys.path.append(os.getcwd()) # Necessary when colcon build invokes this script

  from pydoc import locate
  from src.parsers.msg_parser import decompose_ros_msg_type, get_grpc_type, get_upper_struct
  from src.parsers.param_parser import ParamParser, header_format, namespace_format

  params = ParamParser()
  for a_type in params.types_:
      cog.outl("//----------"+header_format(a_type)+"---------------")
      fields = decompose_ros_msg_type(locate(a_type[0]+".msg."+a_type[1]))
      fields.insert(0,("grpc_object", 0, "STRUCT")) # Insert the received grpc_object as the uppermost base struct
      cog.outl("template <> inline")
      cog.outl("void packWriteItem<{}>(::Arp::Plc::Gds::Services::Grpc::WriteItem* grpc_object, {} data_to_pack)"
              .format(namespace_format(a_type),
                      namespace_format(a_type)))

      cog.outl("{")
      cog.outl("  grpc_object->mutable_value()->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);")
      cog.outl("")
      for ind in range(1, len(fields)): # skip the 0th element, which is the base struct
          nam = fields[ind][0]
          lvl = fields[ind][1]
          typ = fields[ind][2]

          # Handling special types
          # @TODO: How to handle time properly? CT_XX? set_XXvalue()??
          typ = "double" if typ=="float64" else typ

          var_name = fields[ind][0].replace(".","_")
          grpc_typ = get_grpc_type(fields[ind][2])
          upper = get_upper_struct(fields[:ind], lvl-1) # slice till current index, look for first higher struct

          # Line 1 of boilerplate code
          if upper == "grpc_object":
              cog.outl("  ::Arp::Type::Grpc::ObjectType* {} = {}->mutable_value()->mutable_structvalue()->add_structelements();"
                  .format(var_name, upper))
          else:
              cog.outl("  ::Arp::Type::Grpc::ObjectType* {} = {}->mutable_structvalue()->add_structelements();"
                  .format(var_name, upper))

          # Line 2 of boilerplate code
          if "[" in typ: # Assuming from empirical evidence that array types have '[' in the type names
              cog.outl("  {}->set_typecode(::Arp::Type::Grpc::CoreType::CT_Array);".format(var_name))
          else:
              cog.outl("  {}->set_typecode(::Arp::Type::Grpc::CoreType::{});".format(var_name, grpc_typ))

          # Line 3 of boilerplate code
          if typ != "STRUCT":
              # Special handling for arrays
              if "[" in typ: # Assuming from empirical evidence that array types have '[' in the type names
                  array_var = var_name+"_array"
                  array_typ = typ.split('[')[0] # Get the type of the array
                  array_typ = "double" if array_typ=="float64" else array_typ
                  cog.outl("  ::Arp::Type::Grpc::TypeArray* {} = {}->mutable_arrayvalue();".format(array_var, var_name))
                  cog.outl("  for (auto datum : data_to_pack.{})".format(nam))
                  cog.outl("  {")
                  cog.outl("    ObjectType* elem = {}->add_arrayelements();".format(array_var))
                  cog.outl("    elem->set_typecode(::Arp::Type::Grpc::CoreType::{});".format(get_grpc_type(array_typ)))
                  cog.outl("    elem->set_{}value(datum);".format(array_typ))
                  cog.outl("  }")
              # Special handling for time type
              elif typ == "time":
                  cog.outl("  // time type is specially handled as a double type of \'sec.nsec\'")
                  cog.outl("  double nsec_to_double = data_to_pack.header.stamp.nsec/pow(10, 9);  // ROS1 time.nsec typically has 9 digit precision")
                  cog.outl("  double stamp_to_double = data_to_pack.header.stamp.sec + nsec_to_double;")
                  cog.outl("  {}->set_doublevalue(stamp_to_double);".format(var_name))
              else:
                  cog.outl("  {}->set_{}value(data_to_pack.{});".format(var_name, typ, nam))
          cog.outl("")

      cog.outl("}")
      cog.outl("")
  ]]]*/
  //----------nav_msgs/Odometry---------------
  template <> inline
  void packWriteItem<nav_msgs::Odometry>(::Arp::Plc::Gds::Services::Grpc::WriteItem* grpc_object, nav_msgs::Odometry data_to_pack)
  {
    grpc_object->mutable_value()->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* header_1 = grpc_object->mutable_value()->mutable_structvalue()->add_structelements();
    header_1->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* header_seq = header_1->mutable_structvalue()->add_structelements();
    header_seq->set_typecode(::Arp::Type::Grpc::CoreType::CT_Uint32);
    header_seq->set_uint32value(data_to_pack.header.seq);

    ::Arp::Type::Grpc::ObjectType* header_stamp = header_1->mutable_structvalue()->add_structelements();
    header_stamp->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    // time type is specially handled as a double type of 'sec.nsec'
    double nsec_to_double = data_to_pack.header.stamp.nsec/pow(10, 9);  // ROS1 time.nsec typically has 9 digit precision
    double stamp_to_double = data_to_pack.header.stamp.sec + nsec_to_double;
    header_stamp->set_doublevalue(stamp_to_double);

    ::Arp::Type::Grpc::ObjectType* header_frame_id = header_1->mutable_structvalue()->add_structelements();
    header_frame_id->set_typecode(::Arp::Type::Grpc::CoreType::CT_String);
    header_frame_id->set_stringvalue(data_to_pack.header.frame_id);

    ::Arp::Type::Grpc::ObjectType* child_frame_id = grpc_object->mutable_value()->mutable_structvalue()->add_structelements();
    child_frame_id->set_typecode(::Arp::Type::Grpc::CoreType::CT_String);
    child_frame_id->set_stringvalue(data_to_pack.child_frame_id);

    ::Arp::Type::Grpc::ObjectType* pose_1 = grpc_object->mutable_value()->mutable_structvalue()->add_structelements();
    pose_1->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* pose_2 = pose_1->mutable_structvalue()->add_structelements();
    pose_2->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* position_3 = pose_2->mutable_structvalue()->add_structelements();
    position_3->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* pose_pose_position_x = position_3->mutable_structvalue()->add_structelements();
    pose_pose_position_x->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    pose_pose_position_x->set_doublevalue(data_to_pack.pose.pose.position.x);

    ::Arp::Type::Grpc::ObjectType* pose_pose_position_y = position_3->mutable_structvalue()->add_structelements();
    pose_pose_position_y->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    pose_pose_position_y->set_doublevalue(data_to_pack.pose.pose.position.y);

    ::Arp::Type::Grpc::ObjectType* pose_pose_position_z = position_3->mutable_structvalue()->add_structelements();
    pose_pose_position_z->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    pose_pose_position_z->set_doublevalue(data_to_pack.pose.pose.position.z);

    ::Arp::Type::Grpc::ObjectType* orientation_3 = pose_2->mutable_structvalue()->add_structelements();
    orientation_3->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* pose_pose_orientation_x = orientation_3->mutable_structvalue()->add_structelements();
    pose_pose_orientation_x->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    pose_pose_orientation_x->set_doublevalue(data_to_pack.pose.pose.orientation.x);

    ::Arp::Type::Grpc::ObjectType* pose_pose_orientation_y = orientation_3->mutable_structvalue()->add_structelements();
    pose_pose_orientation_y->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    pose_pose_orientation_y->set_doublevalue(data_to_pack.pose.pose.orientation.y);

    ::Arp::Type::Grpc::ObjectType* pose_pose_orientation_z = orientation_3->mutable_structvalue()->add_structelements();
    pose_pose_orientation_z->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    pose_pose_orientation_z->set_doublevalue(data_to_pack.pose.pose.orientation.z);

    ::Arp::Type::Grpc::ObjectType* pose_pose_orientation_w = orientation_3->mutable_structvalue()->add_structelements();
    pose_pose_orientation_w->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    pose_pose_orientation_w->set_doublevalue(data_to_pack.pose.pose.orientation.w);

    ::Arp::Type::Grpc::ObjectType* pose_covariance = pose_1->mutable_structvalue()->add_structelements();
    pose_covariance->set_typecode(::Arp::Type::Grpc::CoreType::CT_Array);
    ::Arp::Type::Grpc::TypeArray* pose_covariance_array = pose_covariance->mutable_arrayvalue();
    for (auto datum : data_to_pack.pose.covariance)
    {
      ObjectType* elem = pose_covariance_array->add_arrayelements();
      elem->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
      elem->set_doublevalue(datum);
    }

    ::Arp::Type::Grpc::ObjectType* twist_1 = grpc_object->mutable_value()->mutable_structvalue()->add_structelements();
    twist_1->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* twist_2 = twist_1->mutable_structvalue()->add_structelements();
    twist_2->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* linear_3 = twist_2->mutable_structvalue()->add_structelements();
    linear_3->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* twist_twist_linear_x = linear_3->mutable_structvalue()->add_structelements();
    twist_twist_linear_x->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    twist_twist_linear_x->set_doublevalue(data_to_pack.twist.twist.linear.x);

    ::Arp::Type::Grpc::ObjectType* twist_twist_linear_y = linear_3->mutable_structvalue()->add_structelements();
    twist_twist_linear_y->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    twist_twist_linear_y->set_doublevalue(data_to_pack.twist.twist.linear.y);

    ::Arp::Type::Grpc::ObjectType* twist_twist_linear_z = linear_3->mutable_structvalue()->add_structelements();
    twist_twist_linear_z->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    twist_twist_linear_z->set_doublevalue(data_to_pack.twist.twist.linear.z);

    ::Arp::Type::Grpc::ObjectType* angular_3 = twist_2->mutable_structvalue()->add_structelements();
    angular_3->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* twist_twist_angular_x = angular_3->mutable_structvalue()->add_structelements();
    twist_twist_angular_x->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    twist_twist_angular_x->set_doublevalue(data_to_pack.twist.twist.angular.x);

    ::Arp::Type::Grpc::ObjectType* twist_twist_angular_y = angular_3->mutable_structvalue()->add_structelements();
    twist_twist_angular_y->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    twist_twist_angular_y->set_doublevalue(data_to_pack.twist.twist.angular.y);

    ::Arp::Type::Grpc::ObjectType* twist_twist_angular_z = angular_3->mutable_structvalue()->add_structelements();
    twist_twist_angular_z->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    twist_twist_angular_z->set_doublevalue(data_to_pack.twist.twist.angular.z);

    ::Arp::Type::Grpc::ObjectType* twist_covariance = twist_1->mutable_structvalue()->add_structelements();
    twist_covariance->set_typecode(::Arp::Type::Grpc::CoreType::CT_Array);
    ::Arp::Type::Grpc::TypeArray* twist_covariance_array = twist_covariance->mutable_arrayvalue();
    for (auto datum : data_to_pack.twist.covariance)
    {
      ObjectType* elem = twist_covariance_array->add_arrayelements();
      elem->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
      elem->set_doublevalue(datum);
    }

  }

  //----------geometry_msgs/Twist---------------
  template <> inline
  void packWriteItem<geometry_msgs::Twist>(::Arp::Plc::Gds::Services::Grpc::WriteItem* grpc_object, geometry_msgs::Twist data_to_pack)
  {
    grpc_object->mutable_value()->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* linear_1 = grpc_object->mutable_value()->mutable_structvalue()->add_structelements();
    linear_1->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* linear_x = linear_1->mutable_structvalue()->add_structelements();
    linear_x->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    linear_x->set_doublevalue(data_to_pack.linear.x);

    ::Arp::Type::Grpc::ObjectType* linear_y = linear_1->mutable_structvalue()->add_structelements();
    linear_y->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    linear_y->set_doublevalue(data_to_pack.linear.y);

    ::Arp::Type::Grpc::ObjectType* linear_z = linear_1->mutable_structvalue()->add_structelements();
    linear_z->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    linear_z->set_doublevalue(data_to_pack.linear.z);

    ::Arp::Type::Grpc::ObjectType* angular_1 = grpc_object->mutable_value()->mutable_structvalue()->add_structelements();
    angular_1->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* angular_x = angular_1->mutable_structvalue()->add_structelements();
    angular_x->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    angular_x->set_doublevalue(data_to_pack.angular.x);

    ::Arp::Type::Grpc::ObjectType* angular_y = angular_1->mutable_structvalue()->add_structelements();
    angular_y->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    angular_y->set_doublevalue(data_to_pack.angular.y);

    ::Arp::Type::Grpc::ObjectType* angular_z = angular_1->mutable_structvalue()->add_structelements();
    angular_z->set_typecode(::Arp::Type::Grpc::CoreType::CT_Real64);
    angular_z->set_doublevalue(data_to_pack.angular.z);

  }

  //----------std_msgs/String---------------
  template <> inline
  void packWriteItem<std_msgs::String>(::Arp::Plc::Gds::Services::Grpc::WriteItem* grpc_object, std_msgs::String data_to_pack)
  {
    grpc_object->mutable_value()->set_typecode(::Arp::Type::Grpc::CoreType::CT_Struct);

    ::Arp::Type::Grpc::ObjectType* data = grpc_object->mutable_value()->mutable_structvalue()->add_structelements();
    data->set_typecode(::Arp::Type::Grpc::CoreType::CT_String);
    data->set_stringvalue(data_to_pack.data);

  }

  //[[[end]]]

  ///
  /// The above section is generated by cog at build time. Manual edits will be lost when rebuilt.
  ///

}

#endif // WRITE_CONVERSIONS_HPP
