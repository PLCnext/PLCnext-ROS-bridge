// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: IDataLoggerService2.proto
// Original file comments:
// /////////////////////////////////////////////////////////////////////////////
//
//  Copyright PHOENIX CONTACT Electronics GmbH
//
// /////////////////////////////////////////////////////////////////////////////
//
#ifndef GRPC_IDataLoggerService2_2eproto__INCLUDED
#define GRPC_IDataLoggerService2_2eproto__INCLUDED

#include "IDataLoggerService2.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace Arp {
namespace Services {
namespace DataLogger {
namespace Services {
namespace Grpc {

// *
// The DataLogger provides an interface to log and store variables during firmware runtime.
//
class IDataLoggerService2 final {
 public:
  static constexpr char const* service_full_name() {
    return "Arp.Services.DataLogger.Services.Grpc.IDataLoggerService2";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / <summary>
    // / List all names of sessions inside the data logger component.
    // / </summary>
    // / <returns>Array of session names.</returns>
    virtual ::grpc::Status ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>> AsyncListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>>(AsyncListSessionNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>> PrepareAsyncListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>>(PrepareAsyncListSessionNamesRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to create a new session.
    // / </summary>
    // / <param name="sessionName">Name of session to be created.</param>
    // / <param name="persistent">If set to <c>true</c>, the newly created session will not be removed when the RSC connection is closed.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>> AsyncCreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>>(AsyncCreateSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>> PrepareAsyncCreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>>(PrepareAsyncCreateSessionRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to remove a session.
    // / </summary>
    // / <param name="sessionName">Name of session to be removed.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>> AsyncRemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>>(AsyncRemoveSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>> PrepareAsyncRemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>>(PrepareAsyncRemoveSessionRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to start a logging session.
    // / </summary>
    // / <param name="sessionName">Name of session to be started.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>> AsyncStartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>>(AsyncStartSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>> PrepareAsyncStartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>>(PrepareAsyncStartSessionRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to stop a logging session.
    // / </summary>
    // / <param name="sessionName">Name of session to be stopped.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>> AsyncStopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>>(AsyncStopSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>> PrepareAsyncStopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>>(PrepareAsyncStopSessionRaw(context, request, cq));
    }
    // / <summary>
    // / (Re)configures a session
    // / </summary>
    // / <param name="sessionname">Name of session to be created or reconfigured</param>
    // / <param name="properties">Collection of attributes forming the configuration for the session</param>
    // / <returns>
    // / <cref name="ErrorCode" /> for more details</returns>
    virtual ::grpc::Status ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>> AsyncConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>>(AsyncConfigureSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>> PrepareAsyncConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>>(PrepareAsyncConfigureSessionRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to query the current configuration of a session
    // / </summary>
    // / <param name="sessionname">Name of session to be queried</param>
    // / <param name="properties">Collection of attributes forming the sessions configuration after successfull invocation</param>
    // / <param name="isPersistent">Determines if the session will remain (<c>true</c>) when the connection to the server is closed or not</param>
    // / <returns>
    // / <cref name="ErrorCode" /> for more details</returns>
    virtual ::grpc::Status GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>> AsyncGetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>>(AsyncGetSessionConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>> PrepareAsyncGetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>>(PrepareAsyncGetSessionConfigurationRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to query the state of a session.
    // / </summary>
    // / <param name="sessionName">Name of session to query state of.</param>
    // / <param name="state">Container for state of session, if session exists. The value after return from call is
    // / unspecified if the session does not exists.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>> AsyncGetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>>(AsyncGetSessionStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>> PrepareAsyncGetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>>(PrepareAsyncGetSessionStateRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to add a variable to a session.
    // / </summary>
    // / <param name="sessionName">Name of session where variable should be added.</param>
    // / <param name="variableNames">Name of variable to be added to session.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>> AsyncSetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>>(AsyncSetVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>> PrepareAsyncSetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>>(PrepareAsyncSetVariablesRaw(context, request, cq));
    }
    // / <summary>
    // / Queries all infos about logged variables of a session.
    // / </summary>
    // / <param name="sessionName">Name of session to query logged variables</param>
    // / <param name="infos">Iterator which can be used to list logged variables after successful call</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>> AsyncGetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>>(AsyncGetLoggedVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>> PrepareAsyncGetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>>(PrepareAsyncGetLoggedVariablesRaw(context, request, cq));
    }
    // / <summary>
    // / Read the data from the given variable from the session with the session name.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the passed variable names including timestamps and data series consistent flags,
    // / which is called a record.
    // / In a record the values are in a static order and doesn't contain
    // / any type information. Each record starts with the timestamp followed by
    // / the values from the given variable by names and the consistent flag. The
    // / record ends with a record type describing the cycle the record belongs to.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Read variables from task A: a1, a2
    // / from task B: b1
    // /
    // / Results in:
    // / object[]
    // / timestamp task A, a1, a2, b1, consistent flag, record type
    // / timestamp task B, a1, a2, b1, consistent flag, record type
    // / </code></para>
    // / <para>
    // / The number of records depends on the given start and end time.
    // / Each values will be returned between the start and end time.
    // /
    // / If the start time is zero, all available records until the end time
    // / will be returned.
    // /
    // / If the end time is zero, all available records from the start time until
    // / the last available record is reached will be returned.
    // /
    // / If the start and end time is zero, each available record will be returned.
    // /
    // / If the start time is greater than the end time, the resulted values are returned
    // / in descending order.
    // / </para>
    // / </remarks>
    // / <param name="sessionName">Name of session where variable should be read from.</param>
    // / <param name="startTime">Start time to be read data.</param>
    // / <param name="endTime">End time to be read data.</param>
    // / <param name="variableNames">Name of variables to be read data.</param>
    // / <param name="values">An enumerator which stores the read values.</param>
    // / <returns>Returns <see cref="Arp.Device.Interface.Services.ErrorCode.None" /> on success.</returns>
    virtual ::grpc::Status ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>> AsyncReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>>(AsyncReadVariablesDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>> PrepareAsyncReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>>(PrepareAsyncReadVariablesDataRaw(context, request, cq));
    }
    // / <summary>
    // / Returns names of all files that have been written by a session
    // / </summary>
    // / <param name="sessionname">Name of session from which rotated files should be listed</param>
    // / <param name="filenames">Iterator to list names of all rotated files on successful call.</param>
    // / <returns>
    // / ErrorCode.NoData in case the session has no data sink configured.
    // / </returns>
    virtual ::grpc::Status GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>> AsyncGetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>>(AsyncGetRotatedFileNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>> PrepareAsyncGetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>>(PrepareAsyncGetRotatedFileNamesRaw(context, request, cq));
    }
    // / <summary>
    // / Tries to retrieve names of sessions which log assigned variables
    // / </summary>
    // / <param name="variablename">Name of variable to which corresponding sessions should be found</param>
    // / <returns>Enumeration of names of sessions which log the variable in question</returns>
    virtual ::grpc::Status GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>> AsyncGetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>>(AsyncGetSessionNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>> PrepareAsyncGetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>>(PrepareAsyncGetSessionNamesRaw(context, request, cq));
    }
    // / <summary>
    // / Sets a trigger condition
    // / </summary>
    // / <remarks>
    // / Configuration of the trigger is done in RPN (Reverse Polish Notation). Each operand or operation is a single <see cref="Arp.Device.Interface.Services.TriggerRpnItem" />. Only
    // / if the condition specified by the trigger is fullfilled values are logged and stored inside the sink.
    // /
    // / The amount of cycles that should be stored before the condition was fullfilled can be configured using <c>preCycleCount</c> whereas the amount of
    // / cycles that should be recorded afterwards can be configured using <c>postCycleCount</c>. If <c>postCycleCount</c> is set to 0 then the
    // / recording continues until IDataLoggerService::StopSession is called or the PLC project is stopped.
    // / </remarks>
    // / <param name="sessionName">Name of session to set trigger condition</param>
    // / <param name="taskName">Name of task where trigger condition is evaluated</param>
    // / <param name="preCycleCount">Amount of datasets recorded before the condition was triggered</param>
    // / <param name="postCycleCount">Amount of dataset recorded ater the condition is triggered (0 means endless)</param>
    // / <param name="triggerCondition">List of trigger items. All items are evaluated in order of their position inside the list.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>> AsyncSetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>>(AsyncSetTriggerConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>> PrepareAsyncSetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>>(PrepareAsyncSetTriggerConditionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // / <summary>
      // / List all names of sessions inside the data logger component.
      // / </summary>
      // / <returns>Array of session names.</returns>
      virtual void ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to create a new session.
      // / </summary>
      // / <param name="sessionName">Name of session to be created.</param>
      // / <param name="persistent">If set to <c>true</c>, the newly created session will not be removed when the RSC connection is closed.</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to remove a session.
      // / </summary>
      // / <param name="sessionName">Name of session to be removed.</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to start a logging session.
      // / </summary>
      // / <param name="sessionName">Name of session to be started.</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to stop a logging session.
      // / </summary>
      // / <param name="sessionName">Name of session to be stopped.</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / (Re)configures a session
      // / </summary>
      // / <param name="sessionname">Name of session to be created or reconfigured</param>
      // / <param name="properties">Collection of attributes forming the configuration for the session</param>
      // / <returns>
      // / <cref name="ErrorCode" /> for more details</returns>
      virtual void ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to query the current configuration of a session
      // / </summary>
      // / <param name="sessionname">Name of session to be queried</param>
      // / <param name="properties">Collection of attributes forming the sessions configuration after successfull invocation</param>
      // / <param name="isPersistent">Determines if the session will remain (<c>true</c>) when the connection to the server is closed or not</param>
      // / <returns>
      // / <cref name="ErrorCode" /> for more details</returns>
      virtual void GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to query the state of a session.
      // / </summary>
      // / <param name="sessionName">Name of session to query state of.</param>
      // / <param name="state">Container for state of session, if session exists. The value after return from call is
      // / unspecified if the session does not exists.</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to add a variable to a session.
      // / </summary>
      // / <param name="sessionName">Name of session where variable should be added.</param>
      // / <param name="variableNames">Name of variable to be added to session.</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Queries all infos about logged variables of a session.
      // / </summary>
      // / <param name="sessionName">Name of session to query logged variables</param>
      // / <param name="infos">Iterator which can be used to list logged variables after successful call</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Read the data from the given variable from the session with the session name.
      // / </summary>
      // / <remarks>
      // / <para>
      // / This service function returns the plain data values from
      // / the passed variable names including timestamps and data series consistent flags,
      // / which is called a record.
      // / In a record the values are in a static order and doesn't contain
      // / any type information. Each record starts with the timestamp followed by
      // / the values from the given variable by names and the consistent flag. The
      // / record ends with a record type describing the cycle the record belongs to.
      // / </para>
      // / <para>
      // / Example:
      // / <code>
      // / Read variables from task A: a1, a2
      // / from task B: b1
      // /
      // / Results in:
      // / object[]
      // / timestamp task A, a1, a2, b1, consistent flag, record type
      // / timestamp task B, a1, a2, b1, consistent flag, record type
      // / </code></para>
      // / <para>
      // / The number of records depends on the given start and end time.
      // / Each values will be returned between the start and end time.
      // /
      // / If the start time is zero, all available records until the end time
      // / will be returned.
      // /
      // / If the end time is zero, all available records from the start time until
      // / the last available record is reached will be returned.
      // /
      // / If the start and end time is zero, each available record will be returned.
      // /
      // / If the start time is greater than the end time, the resulted values are returned
      // / in descending order.
      // / </para>
      // / </remarks>
      // / <param name="sessionName">Name of session where variable should be read from.</param>
      // / <param name="startTime">Start time to be read data.</param>
      // / <param name="endTime">End time to be read data.</param>
      // / <param name="variableNames">Name of variables to be read data.</param>
      // / <param name="values">An enumerator which stores the read values.</param>
      // / <returns>Returns <see cref="Arp.Device.Interface.Services.ErrorCode.None" /> on success.</returns>
      virtual void ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Returns names of all files that have been written by a session
      // / </summary>
      // / <param name="sessionname">Name of session from which rotated files should be listed</param>
      // / <param name="filenames">Iterator to list names of all rotated files on successful call.</param>
      // / <returns>
      // / ErrorCode.NoData in case the session has no data sink configured.
      // / </returns>
      virtual void GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Tries to retrieve names of sessions which log assigned variables
      // / </summary>
      // / <param name="variablename">Name of variable to which corresponding sessions should be found</param>
      // / <returns>Enumeration of names of sessions which log the variable in question</returns>
      virtual void GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Sets a trigger condition
      // / </summary>
      // / <remarks>
      // / Configuration of the trigger is done in RPN (Reverse Polish Notation). Each operand or operation is a single <see cref="Arp.Device.Interface.Services.TriggerRpnItem" />. Only
      // / if the condition specified by the trigger is fullfilled values are logged and stored inside the sink.
      // /
      // / The amount of cycles that should be stored before the condition was fullfilled can be configured using <c>preCycleCount</c> whereas the amount of
      // / cycles that should be recorded afterwards can be configured using <c>postCycleCount</c>. If <c>postCycleCount</c> is set to 0 then the
      // / recording continues until IDataLoggerService::StopSession is called or the PLC project is stopped.
      // / </remarks>
      // / <param name="sessionName">Name of session to set trigger condition</param>
      // / <param name="taskName">Name of task where trigger condition is evaluated</param>
      // / <param name="preCycleCount">Amount of datasets recorded before the condition was triggered</param>
      // / <param name="postCycleCount">Amount of dataset recorded ater the condition is triggered (0 means endless)</param>
      // / <param name="triggerCondition">List of trigger items. All items are evaluated in order of their position inside the list.</param>
      // / <returns>
      // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
      virtual void SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* AsyncListSessionNamesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* PrepareAsyncListSessionNamesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* AsyncCreateSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* PrepareAsyncCreateSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* AsyncRemoveSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* PrepareAsyncRemoveSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* AsyncStartSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* PrepareAsyncStartSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* AsyncStopSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* PrepareAsyncStopSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* AsyncConfigureSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* PrepareAsyncConfigureSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* AsyncGetSessionConfigurationRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* PrepareAsyncGetSessionConfigurationRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* AsyncGetSessionStateRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* PrepareAsyncGetSessionStateRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* AsyncSetVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* PrepareAsyncSetVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* AsyncGetLoggedVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* PrepareAsyncGetLoggedVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* AsyncReadVariablesDataRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* PrepareAsyncReadVariablesDataRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* AsyncGetRotatedFileNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* PrepareAsyncGetRotatedFileNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* AsyncGetSessionNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* PrepareAsyncGetSessionNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* AsyncSetTriggerConditionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* PrepareAsyncSetTriggerConditionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>> AsyncListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>>(AsyncListSessionNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>> PrepareAsyncListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>>(PrepareAsyncListSessionNamesRaw(context, request, cq));
    }
    ::grpc::Status CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>> AsyncCreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>>(AsyncCreateSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>> PrepareAsyncCreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>>(PrepareAsyncCreateSessionRaw(context, request, cq));
    }
    ::grpc::Status RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>> AsyncRemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>>(AsyncRemoveSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>> PrepareAsyncRemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>>(PrepareAsyncRemoveSessionRaw(context, request, cq));
    }
    ::grpc::Status StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>> AsyncStartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>>(AsyncStartSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>> PrepareAsyncStartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>>(PrepareAsyncStartSessionRaw(context, request, cq));
    }
    ::grpc::Status StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>> AsyncStopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>>(AsyncStopSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>> PrepareAsyncStopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>>(PrepareAsyncStopSessionRaw(context, request, cq));
    }
    ::grpc::Status ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>> AsyncConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>>(AsyncConfigureSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>> PrepareAsyncConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>>(PrepareAsyncConfigureSessionRaw(context, request, cq));
    }
    ::grpc::Status GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>> AsyncGetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>>(AsyncGetSessionConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>> PrepareAsyncGetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>>(PrepareAsyncGetSessionConfigurationRaw(context, request, cq));
    }
    ::grpc::Status GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>> AsyncGetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>>(AsyncGetSessionStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>> PrepareAsyncGetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>>(PrepareAsyncGetSessionStateRaw(context, request, cq));
    }
    ::grpc::Status SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>> AsyncSetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>>(AsyncSetVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>> PrepareAsyncSetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>>(PrepareAsyncSetVariablesRaw(context, request, cq));
    }
    ::grpc::Status GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>> AsyncGetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>>(AsyncGetLoggedVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>> PrepareAsyncGetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>>(PrepareAsyncGetLoggedVariablesRaw(context, request, cq));
    }
    ::grpc::Status ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>> AsyncReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>>(AsyncReadVariablesDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>> PrepareAsyncReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>>(PrepareAsyncReadVariablesDataRaw(context, request, cq));
    }
    ::grpc::Status GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>> AsyncGetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>>(AsyncGetRotatedFileNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>> PrepareAsyncGetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>>(PrepareAsyncGetRotatedFileNamesRaw(context, request, cq));
    }
    ::grpc::Status GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>> AsyncGetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>>(AsyncGetSessionNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>> PrepareAsyncGetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>>(PrepareAsyncGetSessionNamesRaw(context, request, cq));
    }
    ::grpc::Status SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>> AsyncSetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>>(AsyncSetTriggerConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>> PrepareAsyncSetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>>(PrepareAsyncSetTriggerConditionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListSessionNames(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StartSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StopSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ConfigureSession(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSessionConfiguration(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSessionState(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLoggedVariables(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadVariablesData(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRotatedFileNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSessionNames(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetTriggerCondition(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* AsyncListSessionNamesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* PrepareAsyncListSessionNamesRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* AsyncCreateSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* PrepareAsyncCreateSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* AsyncRemoveSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* PrepareAsyncRemoveSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* AsyncStartSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* PrepareAsyncStartSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* AsyncStopSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* PrepareAsyncStopSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* AsyncConfigureSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* PrepareAsyncConfigureSessionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* AsyncGetSessionConfigurationRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* PrepareAsyncGetSessionConfigurationRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* AsyncGetSessionStateRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* PrepareAsyncGetSessionStateRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* AsyncSetVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* PrepareAsyncSetVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* AsyncGetLoggedVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* PrepareAsyncGetLoggedVariablesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* AsyncReadVariablesDataRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* PrepareAsyncReadVariablesDataRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* AsyncGetRotatedFileNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* PrepareAsyncGetRotatedFileNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* AsyncGetSessionNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* PrepareAsyncGetSessionNamesRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* AsyncSetTriggerConditionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* PrepareAsyncSetTriggerConditionRaw(::grpc::ClientContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListSessionNames_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateSession_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveSession_;
    const ::grpc::internal::RpcMethod rpcmethod_StartSession_;
    const ::grpc::internal::RpcMethod rpcmethod_StopSession_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigureSession_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSessionConfiguration_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSessionState_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVariables_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLoggedVariables_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadVariablesData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRotatedFileNames_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSessionNames_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTriggerCondition_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / <summary>
    // / List all names of sessions inside the data logger component.
    // / </summary>
    // / <returns>Array of session names.</returns>
    virtual ::grpc::Status ListSessionNames(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response);
    // / <summary>
    // / Tries to create a new session.
    // / </summary>
    // / <param name="sessionName">Name of session to be created.</param>
    // / <param name="persistent">If set to <c>true</c>, the newly created session will not be removed when the RSC connection is closed.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status CreateSession(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response);
    // / <summary>
    // / Tries to remove a session.
    // / </summary>
    // / <param name="sessionName">Name of session to be removed.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status RemoveSession(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response);
    // / <summary>
    // / Tries to start a logging session.
    // / </summary>
    // / <param name="sessionName">Name of session to be started.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status StartSession(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response);
    // / <summary>
    // / Tries to stop a logging session.
    // / </summary>
    // / <param name="sessionName">Name of session to be stopped.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status StopSession(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response);
    // / <summary>
    // / (Re)configures a session
    // / </summary>
    // / <param name="sessionname">Name of session to be created or reconfigured</param>
    // / <param name="properties">Collection of attributes forming the configuration for the session</param>
    // / <returns>
    // / <cref name="ErrorCode" /> for more details</returns>
    virtual ::grpc::Status ConfigureSession(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response);
    // / <summary>
    // / Tries to query the current configuration of a session
    // / </summary>
    // / <param name="sessionname">Name of session to be queried</param>
    // / <param name="properties">Collection of attributes forming the sessions configuration after successfull invocation</param>
    // / <param name="isPersistent">Determines if the session will remain (<c>true</c>) when the connection to the server is closed or not</param>
    // / <returns>
    // / <cref name="ErrorCode" /> for more details</returns>
    virtual ::grpc::Status GetSessionConfiguration(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response);
    // / <summary>
    // / Tries to query the state of a session.
    // / </summary>
    // / <param name="sessionName">Name of session to query state of.</param>
    // / <param name="state">Container for state of session, if session exists. The value after return from call is
    // / unspecified if the session does not exists.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status GetSessionState(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response);
    // / <summary>
    // / Tries to add a variable to a session.
    // / </summary>
    // / <param name="sessionName">Name of session where variable should be added.</param>
    // / <param name="variableNames">Name of variable to be added to session.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status SetVariables(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response);
    // / <summary>
    // / Queries all infos about logged variables of a session.
    // / </summary>
    // / <param name="sessionName">Name of session to query logged variables</param>
    // / <param name="infos">Iterator which can be used to list logged variables after successful call</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status GetLoggedVariables(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response);
    // / <summary>
    // / Read the data from the given variable from the session with the session name.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the passed variable names including timestamps and data series consistent flags,
    // / which is called a record.
    // / In a record the values are in a static order and doesn't contain
    // / any type information. Each record starts with the timestamp followed by
    // / the values from the given variable by names and the consistent flag. The
    // / record ends with a record type describing the cycle the record belongs to.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Read variables from task A: a1, a2
    // / from task B: b1
    // /
    // / Results in:
    // / object[]
    // / timestamp task A, a1, a2, b1, consistent flag, record type
    // / timestamp task B, a1, a2, b1, consistent flag, record type
    // / </code></para>
    // / <para>
    // / The number of records depends on the given start and end time.
    // / Each values will be returned between the start and end time.
    // /
    // / If the start time is zero, all available records until the end time
    // / will be returned.
    // /
    // / If the end time is zero, all available records from the start time until
    // / the last available record is reached will be returned.
    // /
    // / If the start and end time is zero, each available record will be returned.
    // /
    // / If the start time is greater than the end time, the resulted values are returned
    // / in descending order.
    // / </para>
    // / </remarks>
    // / <param name="sessionName">Name of session where variable should be read from.</param>
    // / <param name="startTime">Start time to be read data.</param>
    // / <param name="endTime">End time to be read data.</param>
    // / <param name="variableNames">Name of variables to be read data.</param>
    // / <param name="values">An enumerator which stores the read values.</param>
    // / <returns>Returns <see cref="Arp.Device.Interface.Services.ErrorCode.None" /> on success.</returns>
    virtual ::grpc::Status ReadVariablesData(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response);
    // / <summary>
    // / Returns names of all files that have been written by a session
    // / </summary>
    // / <param name="sessionname">Name of session from which rotated files should be listed</param>
    // / <param name="filenames">Iterator to list names of all rotated files on successful call.</param>
    // / <returns>
    // / ErrorCode.NoData in case the session has no data sink configured.
    // / </returns>
    virtual ::grpc::Status GetRotatedFileNames(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response);
    // / <summary>
    // / Tries to retrieve names of sessions which log assigned variables
    // / </summary>
    // / <param name="variablename">Name of variable to which corresponding sessions should be found</param>
    // / <returns>Enumeration of names of sessions which log the variable in question</returns>
    virtual ::grpc::Status GetSessionNames(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response);
    // / <summary>
    // / Sets a trigger condition
    // / </summary>
    // / <remarks>
    // / Configuration of the trigger is done in RPN (Reverse Polish Notation). Each operand or operation is a single <see cref="Arp.Device.Interface.Services.TriggerRpnItem" />. Only
    // / if the condition specified by the trigger is fullfilled values are logged and stored inside the sink.
    // /
    // / The amount of cycles that should be stored before the condition was fullfilled can be configured using <c>preCycleCount</c> whereas the amount of
    // / cycles that should be recorded afterwards can be configured using <c>postCycleCount</c>. If <c>postCycleCount</c> is set to 0 then the
    // / recording continues until IDataLoggerService::StopSession is called or the PLC project is stopped.
    // / </remarks>
    // / <param name="sessionName">Name of session to set trigger condition</param>
    // / <param name="taskName">Name of task where trigger condition is evaluated</param>
    // / <param name="preCycleCount">Amount of datasets recorded before the condition was triggered</param>
    // / <param name="postCycleCount">Amount of dataset recorded ater the condition is triggered (0 means endless)</param>
    // / <param name="triggerCondition">List of trigger items. All items are evaluated in order of their position inside the list.</param>
    // / <returns>
    // / <see cref="Arp.Device.Interface.Services.ErrorCode" /> for more information</returns>
    virtual ::grpc::Status SetTriggerCondition(::grpc::ServerContext* context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListSessionNames() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSessionNames(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSessionNames(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateSession() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CreateSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSession(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveSession() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RemoveSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveSession(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartSession() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartSession(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopSession() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_StopSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopSession(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigureSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConfigureSession() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ConfigureSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigureSession(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSessionConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSessionConfiguration() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetSessionConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionConfiguration(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessionConfiguration(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSessionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSessionState() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetSessionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionState(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessionState(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVariables() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariables(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLoggedVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLoggedVariables() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetLoggedVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoggedVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoggedVariables(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadVariablesData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadVariablesData() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ReadVariablesData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadVariablesData(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadVariablesData(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRotatedFileNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRotatedFileNames() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetRotatedFileNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotatedFileNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRotatedFileNames(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSessionNames() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessionNames(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTriggerCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTriggerCondition() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_SetTriggerCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTriggerCondition(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTriggerCondition(::grpc::ServerContext* context, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListSessionNames<WithAsyncMethod_CreateSession<WithAsyncMethod_RemoveSession<WithAsyncMethod_StartSession<WithAsyncMethod_StopSession<WithAsyncMethod_ConfigureSession<WithAsyncMethod_GetSessionConfiguration<WithAsyncMethod_GetSessionState<WithAsyncMethod_SetVariables<WithAsyncMethod_GetLoggedVariables<WithAsyncMethod_ReadVariablesData<WithAsyncMethod_GetRotatedFileNames<WithAsyncMethod_GetSessionNames<WithAsyncMethod_SetTriggerCondition<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListSessionNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* response) { return this->ListSessionNames(context, request, response); }));}
    void SetMessageAllocatorFor_ListSessionNames(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSessionNames(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSessionNames(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSessionNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* response) { return this->CreateSession(context, request, response); }));}
    void SetMessageAllocatorFor_CreateSession(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateSession(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoveSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoveSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* response) { return this->RemoveSession(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveSession(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemoveSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveSession(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* response) { return this->StartSession(context, request, response); }));}
    void SetMessageAllocatorFor_StartSession(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartSession(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StopSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* response) { return this->StopSession(context, request, response); }));}
    void SetMessageAllocatorFor_StopSession(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopSession(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ConfigureSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ConfigureSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* response) { return this->ConfigureSession(context, request, response); }));}
    void SetMessageAllocatorFor_ConfigureSession(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ConfigureSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ConfigureSession(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ConfigureSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSessionConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSessionConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* response) { return this->GetSessionConfiguration(context, request, response); }));}
    void SetMessageAllocatorFor_GetSessionConfiguration(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSessionConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionConfiguration(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessionConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessionConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSessionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSessionState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* response) { return this->GetSessionState(context, request, response); }));}
    void SetMessageAllocatorFor_GetSessionState(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSessionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionState(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessionState(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessionState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetVariables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* response) { return this->SetVariables(context, request, response); }));}
    void SetMessageAllocatorFor_SetVariables(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetVariables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLoggedVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLoggedVariables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* response) { return this->GetLoggedVariables(context, request, response); }));}
    void SetMessageAllocatorFor_GetLoggedVariables(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLoggedVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoggedVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLoggedVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLoggedVariables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadVariablesData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadVariablesData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* response) { return this->ReadVariablesData(context, request, response); }));}
    void SetMessageAllocatorFor_ReadVariablesData(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadVariablesData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadVariablesData(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadVariablesData(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadVariablesData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRotatedFileNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRotatedFileNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* response) { return this->GetRotatedFileNames(context, request, response); }));}
    void SetMessageAllocatorFor_GetRotatedFileNames(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRotatedFileNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotatedFileNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRotatedFileNames(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRotatedFileNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSessionNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* response) { return this->GetSessionNames(context, request, response); }));}
    void SetMessageAllocatorFor_GetSessionNames(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessionNames(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessionNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetTriggerCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetTriggerCondition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* request, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* response) { return this->SetTriggerCondition(context, request, response); }));}
    void SetMessageAllocatorFor_SetTriggerCondition(
        ::grpc::experimental::MessageAllocator< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetTriggerCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTriggerCondition(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetTriggerCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetTriggerCondition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ListSessionNames<ExperimentalWithCallbackMethod_CreateSession<ExperimentalWithCallbackMethod_RemoveSession<ExperimentalWithCallbackMethod_StartSession<ExperimentalWithCallbackMethod_StopSession<ExperimentalWithCallbackMethod_ConfigureSession<ExperimentalWithCallbackMethod_GetSessionConfiguration<ExperimentalWithCallbackMethod_GetSessionState<ExperimentalWithCallbackMethod_SetVariables<ExperimentalWithCallbackMethod_GetLoggedVariables<ExperimentalWithCallbackMethod_ReadVariablesData<ExperimentalWithCallbackMethod_GetRotatedFileNames<ExperimentalWithCallbackMethod_GetSessionNames<ExperimentalWithCallbackMethod_SetTriggerCondition<Service > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ListSessionNames<ExperimentalWithCallbackMethod_CreateSession<ExperimentalWithCallbackMethod_RemoveSession<ExperimentalWithCallbackMethod_StartSession<ExperimentalWithCallbackMethod_StopSession<ExperimentalWithCallbackMethod_ConfigureSession<ExperimentalWithCallbackMethod_GetSessionConfiguration<ExperimentalWithCallbackMethod_GetSessionState<ExperimentalWithCallbackMethod_SetVariables<ExperimentalWithCallbackMethod_GetLoggedVariables<ExperimentalWithCallbackMethod_ReadVariablesData<ExperimentalWithCallbackMethod_GetRotatedFileNames<ExperimentalWithCallbackMethod_GetSessionNames<ExperimentalWithCallbackMethod_SetTriggerCondition<Service > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListSessionNames() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSessionNames(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateSession() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CreateSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveSession() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RemoveSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartSession() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopSession() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_StopSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigureSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConfigureSession() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ConfigureSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSessionConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSessionConfiguration() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetSessionConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionConfiguration(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSessionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSessionState() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetSessionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionState(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVariables() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLoggedVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLoggedVariables() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetLoggedVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoggedVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadVariablesData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadVariablesData() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ReadVariablesData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadVariablesData(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRotatedFileNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRotatedFileNames() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetRotatedFileNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotatedFileNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSessionNames() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTriggerCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTriggerCondition() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_SetTriggerCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTriggerCondition(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListSessionNames() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSessionNames(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSessionNames(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateSession() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CreateSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSession(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveSession() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RemoveSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveSession(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartSession() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartSession(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopSession() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_StopSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopSession(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigureSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConfigureSession() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ConfigureSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigureSession(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSessionConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSessionConfiguration() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetSessionConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionConfiguration(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessionConfiguration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSessionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSessionState() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetSessionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionState(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessionState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVariables() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLoggedVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLoggedVariables() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetLoggedVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoggedVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoggedVariables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadVariablesData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadVariablesData() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ReadVariablesData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadVariablesData(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadVariablesData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRotatedFileNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRotatedFileNames() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetRotatedFileNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotatedFileNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRotatedFileNames(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSessionNames() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessionNames(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTriggerCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTriggerCondition() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_SetTriggerCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTriggerCondition(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTriggerCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListSessionNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListSessionNames(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSessionNames(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSessionNames(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSessionNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateSession(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateSession(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoveSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoveSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveSession(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoveSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveSession(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartSession(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartSession(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StopSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopSession(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StopSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StopSession(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StopSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ConfigureSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ConfigureSession() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConfigureSession(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ConfigureSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ConfigureSession(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ConfigureSession(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSessionConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSessionConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSessionConfiguration(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSessionConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionConfiguration(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessionConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessionConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSessionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSessionState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSessionState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSessionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionState(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessionState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessionState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetVariables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVariables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetVariables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLoggedVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLoggedVariables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLoggedVariables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLoggedVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoggedVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLoggedVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLoggedVariables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadVariablesData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadVariablesData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadVariablesData(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadVariablesData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadVariablesData(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadVariablesData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadVariablesData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRotatedFileNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRotatedFileNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRotatedFileNames(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRotatedFileNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRotatedFileNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRotatedFileNames(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRotatedFileNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSessionNames() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSessionNames(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessionNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSessionNames(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSessionNames(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetTriggerCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetTriggerCondition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTriggerCondition(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetTriggerCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTriggerCondition(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetTriggerCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetTriggerCondition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListSessionNames() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* streamer) {
                       return this->StreamedListSessionNames(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListSessionNames(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListSessionNames(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ListSessionNamesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateSession() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* streamer) {
                       return this->StreamedCreateSession(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateSession(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2CreateSessionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveSession() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* streamer) {
                       return this->StreamedRemoveSession(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveSession(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2RemoveSessionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartSession() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* streamer) {
                       return this->StreamedStartSession(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartSession(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StartSessionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopSession() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* streamer) {
                       return this->StreamedStopSession(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopSession(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2StopSessionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigureSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConfigureSession() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* streamer) {
                       return this->StreamedConfigureSession(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConfigureSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigureSession(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigureSession(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ConfigureSessionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSessionConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSessionConfiguration() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* streamer) {
                       return this->StreamedGetSessionConfiguration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSessionConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSessionConfiguration(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSessionConfiguration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSessionState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSessionState() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* streamer) {
                       return this->StreamedGetSessionState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSessionState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSessionState(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSessionState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVariables() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* streamer) {
                       return this->StreamedSetVariables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVariables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetVariablesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLoggedVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLoggedVariables() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* streamer) {
                       return this->StreamedGetLoggedVariables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLoggedVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLoggedVariables(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLoggedVariables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetLoggedVariablesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadVariablesData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadVariablesData() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* streamer) {
                       return this->StreamedReadVariablesData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadVariablesData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadVariablesData(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadVariablesData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2ReadVariablesDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRotatedFileNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRotatedFileNames() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* streamer) {
                       return this->StreamedGetRotatedFileNames(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRotatedFileNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRotatedFileNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRotatedFileNames(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetRotatedFileNamesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSessionNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSessionNames() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* streamer) {
                       return this->StreamedGetSessionNames(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSessionNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSessionNames(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSessionNames(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2GetSessionNamesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTriggerCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTriggerCondition() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* streamer) {
                       return this->StreamedSetTriggerCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTriggerCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTriggerCondition(::grpc::ServerContext* /*context*/, const ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest* /*request*/, ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTriggerCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionRequest,::Arp::Services::DataLogger::Services::Grpc::IDataLoggerService2SetTriggerConditionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListSessionNames<WithStreamedUnaryMethod_CreateSession<WithStreamedUnaryMethod_RemoveSession<WithStreamedUnaryMethod_StartSession<WithStreamedUnaryMethod_StopSession<WithStreamedUnaryMethod_ConfigureSession<WithStreamedUnaryMethod_GetSessionConfiguration<WithStreamedUnaryMethod_GetSessionState<WithStreamedUnaryMethod_SetVariables<WithStreamedUnaryMethod_GetLoggedVariables<WithStreamedUnaryMethod_ReadVariablesData<WithStreamedUnaryMethod_GetRotatedFileNames<WithStreamedUnaryMethod_GetSessionNames<WithStreamedUnaryMethod_SetTriggerCondition<Service > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListSessionNames<WithStreamedUnaryMethod_CreateSession<WithStreamedUnaryMethod_RemoveSession<WithStreamedUnaryMethod_StartSession<WithStreamedUnaryMethod_StopSession<WithStreamedUnaryMethod_ConfigureSession<WithStreamedUnaryMethod_GetSessionConfiguration<WithStreamedUnaryMethod_GetSessionState<WithStreamedUnaryMethod_SetVariables<WithStreamedUnaryMethod_GetLoggedVariables<WithStreamedUnaryMethod_ReadVariablesData<WithStreamedUnaryMethod_GetRotatedFileNames<WithStreamedUnaryMethod_GetSessionNames<WithStreamedUnaryMethod_SetTriggerCondition<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace Grpc
}  // namespace Services
}  // namespace DataLogger
}  // namespace Services
}  // namespace Arp


#endif  // GRPC_IDataLoggerService2_2eproto__INCLUDED
