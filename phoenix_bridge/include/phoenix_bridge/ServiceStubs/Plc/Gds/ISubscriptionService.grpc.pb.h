// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ISubscriptionService.proto
// Original file comments:
// /////////////////////////////////////////////////////////////////////////////
//
//  Copyright PHOENIX CONTACT Electronics GmbH
//
// /////////////////////////////////////////////////////////////////////////////
//
#ifndef GRPC_ISubscriptionService_2eproto__INCLUDED
#define GRPC_ISubscriptionService_2eproto__INCLUDED

#include "ISubscriptionService.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace Arp {
namespace Plc {
namespace Gds {
namespace Services {
namespace Grpc {

// *
// Services for the subscription.
// 
// <div>
// <p>The subscription functionality is a more elegant way reading values from variables, in contrast to permanently reading (polling).
// A client can subscribe a selection of variables of interest and the subscription will copy the data values to a internal buffer.
// This is the recommended mechanism to "read" variable values from th PLC system. All read data are always task consistent, because
// the data is written by the task itself.</p><p>The data updating rate depends of the task to which the variable belongs. Because global variables haven't a task affiliation,
// each global variable will be updated by default from the task 'Globals'. This task has a default cycling time of 50ms which is configurable
// via the ESM configuration. For more information to the update rate see {@code M:Arp.Plc.Gds.Services.ISubscriptionService.Subscribe(System.UInt32,System.UInt64)}.</p><p>Initially, the internal buffers are initialized with null values ({@code F:Arp.Plc.DataType.Void}). This is important to know,
// especially if values are read immediately after the subscription is created. More precisely if the data are read
// before the tasks have written the data.</p><p>Additionally a subscription is able to generate timestamps which will be generated at the end of the variable source task.
// {@code M:Arp.Plc.Gds.Services.ISubscriptionService.ReadTimeStampedValues(System.UInt32,System.Object[]@)}</p><p>A client can subscribe to different types of variables provided in {@code T:Arp.Plc.DataType}.
// Currently supported variable types are listed below:</p><p>To address a variable, the full variable name (uri) is necessary. Some valid examples are given below:
// {@code
// ComponentName-1/ProgramName-1.Variable_Name
// ComponentName-1/Global_Variable_Name
// ComponentName-1/ProgramName-1.Array_Variable_Name[index]
// ComponentName-1/ProgramName-1.Array_Variable_Name[startIndex:endIndex]
// ComponentName-1/ProgramName-1.Struct_Variable_Name.Element1.Leaf
// ComponentName-1/ProgramName-1.Struct_Variable_Name.Element1.LeafArray[index]
// ComponentName-1/ProgramName-1.Struct_Variable_Name.Element1.LeafArrayOfArray[indexX][indexY]
// }</p><p>A Subscription can created in the PLC process, in other processes and also on remote targets.</p><p>All subscriptions will be removed after a {@code F:Arp.Plc.Domain.Services.PlcStartKind.Cold} and
// {@code F:Arp.Plc.Domain.Services.PlcStartKind.Warm} start and after a download change.
// While a download change is in process the subscription service will be disabled and each function
// will be return the error code {@code F:Arp.Plc.Gds.Services.DataAccessError.CurrentlyUnavailable}.</p><p>Procedure of usage:
// tdb</p>
// </div>
//
class ISubscriptionService final {
 public:
  static constexpr char const* service_full_name() {
    return "Arp.Plc.Gds.Services.Grpc.ISubscriptionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / <summary>
    // / Creates a subscription of the given <see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This method allows other components, also from remote targets,
    // / to create a subscription which is able to subscribe each PLC variable.
    // / On success it returns a unique <c>SubscriptionId</c> which is
    // / created internally. The <c>SubscriptionId</c> has to be exposed to the SDK
    // / user, due to the usage on remote targets. The <c>SubscriptionId</c> is
    // / the reference to a created subscription at the PLC target and is needed in
    // / each subscription method exclude this and <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
    // / </para>
    // / <para>
    // / Each subscription contains at least one buffer which kind depends on the
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
    // / tasks which contains the added variables. The buffer are initialized with a
    // / <see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
    // / Apart from <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
    // / the task. How often the task stores the data to the buffer depends on the task
    // / cycle time and the configured subscription sample interval.
    // / </para>
    // / <para>
    // / The <see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
    // / created. Each kind has its own benefits and differs in consistence, performance and
    // / memory usage. The available kinds are listed below:
    // / </para>
    // / <list type="table">
    // / <listheader>
    // / <term>kind</term>
    // / <description>description</description>
    // / </listheader>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
    // / </term>
    // / <description>
    // / The subscription itself triggers the copy process and will read the data
    // / directly from the source. This could be the fastest way and with no
    // / influence to the real time, to get the current data, but
    // / the task consistency is not guaranteed.
    // / <para>
    // / Usage example: Asynchronous data collection for non critical data.
    // / </para></description>
    // / </item>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
    // / </term>
    // / <description>
    // / This subscription uses a <c>DoubleBuffer</c> which contains the last
    // / written data from the added variables. This kind is task consistent, has low
    // / influence to the real time and is low in memory usage.
    // / <para>
    // / Usage example: Standard way to collect the variable data.
    // / </para></description>
    // / </item>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
    // / </term>
    // / <description>
    // / This subscription uses a <c>QuadBuffer</c> which contains the last
    // / written data from the added variables. This kind is task consistent, has the
    // / fastest access to the current written data, but uses the fourfold memory.
    // / <para>
    // / Usage example: For variables which are running in high speed tasks and for which
    // / it is necessary to guarantee the fastest access to the current written data.
    // / Note that in most cases the <see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
    // / sufficient.
    // / </para></description>
    // / </item>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
    // / </term>
    // / <description>
    // / This subscription uses a <c>RingBuffer</c> which is able to store
    // / more than one record of data. This kind is task consistent, has low
    // / influence to the real time, but needs, dependent to the ring capacity, a lot
    // / of memory. By default the ring capacity is <c>10</c>, use
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
    // / witch a self defined size.
    // / <para>
    // / Usage example: For variables which are running in faster tasks than the consumer does
    // / and for which it is necessary to guarantee that every data record will be stored,
    // / without a single gap.
    // / Note that this kind uses a lot of memory!
    // / </para></description>
    // / </item>
    // / </list>
    // / <para>
    // / After the subscription is created successfully, variables could be added with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
    // / with the <c>SubscriptionId</c> just returned in this method.
    // / </para>
    // / </remarks>
    // / <param name="kind">
    // / The kind of the subscription.
    // / </param>
    // / <returns>
    // / The unique subscription id on success, otherwise 0.
    // / <para></para></returns>
    virtual ::grpc::Status CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>> AsyncCreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>>(AsyncCreateSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>> PrepareAsyncCreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>>(PrepareAsyncCreateSubscriptionRaw(context, request, cq));
    }
    // / <summary>
    // / Creates a subscription of <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
    // / </summary>
    // / <remarks>
    // / This method creates a subscription of the kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
    // / Compared to the method <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
    // / configure the capacity of the internal used ring buffer.
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
    // / </remarks>
    // / <param name="recordCount">
    // / The maximum number of storable records.
    // / </param>
    // / <returns>
    // / The unique subscription id on success, otherwise 0.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
    virtual ::grpc::Status CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>> AsyncCreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>>(AsyncCreateRecordingSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>> PrepareAsyncCreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>>(PrepareAsyncCreateRecordingSubscriptionRaw(context, request, cq));
    }
    // / <summary>
    // / Extends the subscription with the given id by inserting the given
    // / variable name
    // / </summary>
    // / <remarks>
    // / <para>
    // / The added variable is stored in a internal container and will be
    // / subscribed after calling <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
    // / the subscription has already been subscribed, it is necessary to
    // / call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
    // / added variable finally.
    // / </para>
    // / <para>
    // / If the same full variable name is added multiple times, the old variable will be
    // / overridden. In case, a variable name is invalid or doesn't exists
    // / a specific error code will be returned <see cref="Arp.Device.Interface.Services.DataAccessError" />,
    // / on success the code <see cref="Arp.Device.Interface.Services.DataAccessError.None" />
    // / of the added variable will be returned. A variable which doesn't returned with
    // / <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
    // / and won't be subscribed.
    // / </para>
    // / <para>
    // / A single array element can added with its index in brackets e.g.:
    // / <code>
    // / ComponentName-1/ProgramName-1.Array_Name[index]
    // / </code>
    // /
    // / Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
    // / <code>
    // / ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
    // / </code>
    // /
    // / If an array variable is added without a variable specification,
    // / the entire array will be added to the subscription.
    // / </para>
    // / <para>
    // / An alternative way to insert variables to the subscription is by using
    // / the function <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription where the variable is add to.
    // / </param>
    // / <param name="variableName">
    // / The full name of the variable.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
    virtual ::grpc::Status AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>> AsyncAddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>>(AsyncAddVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>> PrepareAsyncAddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>>(PrepareAsyncAddVariableRaw(context, request, cq));
    }
    // / <summary>
    // / Extends the subscription with the given id by inserting a range of new variables.
    // / </summary>
    // / <remarks>
    // / Allows to add a range of variables to the subscription. The returned array of type <see cref="Arp.Device.Interface.Services.DataAccessError" />,
    // / is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription where the variables are added to.
    // / </param>
    // / <param name="variableNames">
    // / An array of full variable names.
    // / </param>
    // / <returns>
    // / Returns a vector of <see cref="Arp.Device.Interface.Services.DataAccessError" />, <see cref="Arp.Device.Interface.Services.DataAccessError.None" />
    // / on success, in the same order as the variables were added.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
    virtual ::grpc::Status AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>> AsyncAddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>>(AsyncAddVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>> PrepareAsyncAddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>>(PrepareAsyncAddVariablesRaw(context, request, cq));
    }
    // / <summary>
    // / Removes the variable with the specific variable name from the subscription.
    // / </summary>
    // / <remarks>
    // / Removes the variable that compare equal to the given variable name, from the
    // / internal variable list. If the subscription has already been subscribed,
    // / it is necessary to call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
    // / remove the given variable from the internal created buffer.
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="variableName">
    // / The full name of the variable to be removed from the subscription.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>> AsyncRemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>>(AsyncRemoveVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>> PrepareAsyncRemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>>(PrepareAsyncRemoveVariableRaw(context, request, cq));
    }
    // / <summary>
    // / Subscribes the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / All previously added variables including in the given subscription will be subscribed. Internally
    // / the variables are separated in the respective tasks, a buffer for each task will be created and
    // / connected to the task executed event. At this point the task will copy the selected variable data
    // / into the task buffer (excluded subscriptions from kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
    // / How often the task stores the data to the buffer depends on the task cycle time and the
    // / configured subscription sample rate.
    // / </para>
    // / <para>
    // / Calling this method on a already subscribed subscription has no effect, even if new
    // / variables have been added or removed. To make variable modification effective, use
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
    // / <c>Unsubscribed</c>, because <see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
    // / connect the already constructed buffer to the respective tasks and will set the given sampleRate.
    // / Compare to the first and initial call of this method, this call cost more less time because
    // / the buffer are already created. This also means that variable modification which have been
    // / done after the first call of <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
    // / it is also necessary to call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
    // / </para>
    // / <para>
    // / A subscribed subscription can operates in different sample rates (excluded subscriptions from
    // / kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
    // / First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
    // / the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
    // / task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
    // / Thats the case if the given sample rate is set to zero,
    // / which means the subscription operates in <c>'real-time'</c>, the same sample rate the task is operating in.
    // / This is also the fastest possible rate for a subscription.
    // / Note that it's possible that one subscription could contain variables from different tasks, which has the
    // / consequence that the subscription operates in different rates!
    // / If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
    // / no matter from which task this variable comes.
    // / Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
    // / the given rate will rounded down. E.g.:
    // /
    // / <code>
    // / Task A cycle rate = 10ms
    // / Task B cycle rate = 8ms
    // /
    // / Subscription given rate = 50ms
    // /
    // / Subscription rate for task A = 50ms
    // / Subscription rate for task B = 48ms
    // / </code>
    // /
    // / Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
    // / the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
    // / But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
    // / the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
    // / downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
    // / or an multiple of them.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="sampleRate">
    // / The desired sample rate in microseconds.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
    virtual ::grpc::Status Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>> AsyncSubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>>(AsyncSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    // / <summary>
    // / Resubscribes the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / Resubscribes the subscription, which will trigger a completely rebuild process of
    // / the whole subscription, including previously done variable modification which have been
    // / done after the first call of <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
    // / It destroys the internal buffer and subscribes the subscription again
    // / (for further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
    // / Note that the subscription is not able to collect data from the variables, while the
    // / resubscribe process is in progress.
    // / </para>
    // / <para>
    // / This method has only an effect if the given subscription is currently subscribed,
    // / otherwise nothing will happen.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="sampleRate">
    // / The desired sample rate in microseconds.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
    virtual ::grpc::Status Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>> AsyncResubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>>(AsyncResubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>> PrepareAsyncResubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>>(PrepareAsyncResubscribeRaw(context, request, cq));
    }
    // / <summary>
    // / Unsubscribes the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / Unsubscribes the subscription from all task executed events. The subscription
    // / data are still exist and could be get by the respective read-methods. To
    // / subscribe the subscription again, call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
    // / </para>
    // / <para>
    // / This method has only an effect if the given subscription is currently subscribed,
    // / otherwise nothing will happen.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>> AsyncUnsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>>(AsyncUnsubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>> PrepareAsyncUnsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>>(PrepareAsyncUnsubscribeRaw(context, request, cq));
    }
    // / <summary>
    // / Deletes the subscription.
    // / </summary>
    // / <remarks>
    // / Deletes the subscription with the given id. After that the id is no longer valid and all data,
    // / containing in the subscription will be removed.
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>> AsyncDeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>>(AsyncDeleteSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>> PrepareAsyncDeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>>(PrepareAsyncDeleteSubscriptionRaw(context, request, cq));
    }
    // / <summary>
    // / Get the subscribed variable information of the subscription.
    // / </summary>
    // / <remarks>
    // / <para>
    // / The subscription service provides several read functions
    // / (<see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
    // / return the plain values without any information of type and order.
    // / To assign this plain values to the added variables, this function returns
    // / the currently subscribed variable information in a array of
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
    // / This order and type information wont change, till
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
    // / Note that this order does not have to be the same order like the
    // / variables has been added to the subscription.
    // / </para>
    // / <para>
    // / This service function relates to the read function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
    // / The provided information contains only information of the added and
    // / currently subscribed variables. It doesn't contain information
    // / of timestamps. Timestamps could be read by the function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
    // / information with <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / VariableInfo[]
    // / a1
    // / a2
    // / b1
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="variableInfo">
    // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
    // / timestamp information.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>> AsyncGetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>>(AsyncGetVariableInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>> PrepareAsyncGetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>>(PrepareAsyncGetVariableInfosRaw(context, request, cq));
    }
    // / <summary>
    // / Get the subscribed variable information including information
    // / of timestamps of the subscription.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function relates to the read function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
    // / The provided information contains information of the added and
    // / currently subscribed variables and additionally information about the
    // / timestamps. Note that a subscription could contain multiple
    // / timestamps, related on the number of used tasks from which the
    // / added variables are from. The timestamp is always the first value
    // / followed by all to the task related variable information.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / VariableInfo[]
    // / timestamp
    // / a1
    // / a2
    // / timestamp
    // / b1
    // / </code></para>
    // / <para>
    // / Each containing timestamp has the variable name <c>timestamp</c> and
    // / the data type <see cref="Arp.Plc.DataType.Int64" /> which is provided in
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
    // / </para>
    // / <para>
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="variableInfo">
    // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" />.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>> AsyncGetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>>(AsyncGetTimeStampedVariableInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>> PrepareAsyncGetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>>(PrepareAsyncGetTimeStampedVariableInfosRaw(context, request, cq));
    }
    // / <summary>
    // / Get the subscribed variable information as a record of the subscription.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function relates to the read function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
    // / The provided information contains information of the added and
    // / currently subscribed variables, its task relation and additionally
    // / information about the task related timestamp.
    // / </para>
    // / <para>
    // / The information are provided in an array of array of
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
    // / number of different tasks and the second contains the related variable
    // / information which are related to the variables of this task and
    // / additionally information about the task related timestamp.
    // / </para>
    // / <para>
    // / Each containing timestamp has the variable name <c>timestamp</c> and
    // / the data type <see cref="Arp.Plc.DataType.Int64" /> which is provided in
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / VariableInfo[][]
    // / VariableInfo[]
    // / timestamp
    // / a1
    // / a2
    // / VariableInfo[]
    // / timestamp
    // / b1
    // / </code></para>
    // / <para>
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
    // / </para>
    // / <para>
    // / Note: This function is currently not supported in C#!.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="recordInfos">
    // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" />.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>> AsyncGetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>>(AsyncGetRecordInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>> PrepareAsyncGetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>>(PrepareAsyncGetRecordInfosRaw(context, request, cq));
    }
    // / <summary>
    // / Read the data from the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the added and subscribed variables. The data values are returned
    // / in a static order and doesn't contain any type information. To
    // / figure out which value belongs to the added variable, it is necessary
    // / to call the related information function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
    // / As long as the subscription doesn't resubscribed with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
    // / and both, the read value data and information data, are in a static
    // / order.
    // / </para>
    // / <para>
    // / Note that this values doesn't contain timestamps! If the timestamp is
    // / needed use the function <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
    // / instead.
    // / </para>
    // / <para>
    // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
    // / before the tasks initially have written the data.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / object[]
    // / a1
    // / a2
    // / b1
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="values">
    // / Contains the plain values of the given and subscribed variables.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>> AsyncReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>>(AsyncReadValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>> PrepareAsyncReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>>(PrepareAsyncReadValuesRaw(context, request, cq));
    }
    // / <summary>
    // / Read the data including timestamps from the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the added and subscribed variables including timestamps.
    // / The data values are returned in a static order and doesn't contain
    // / any type information. To figure out which value belongs to the added
    // / variable, it is necessary to call the related information function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
    // / As long as the subscription doesn't resubscribed with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
    // / and both, the read value data and information data, are in a static
    // / order.
    // / </para>
    // / <para>
    // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
    // / before the tasks initially have written the data.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / object[]
    // / timestamp task A
    // / a1
    // / a2
    // / timestamp task B
    // / b1
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="values">
    // / Contains the plain values including the timestamps of the
    // / given and subscribed variables.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>> AsyncReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>>(AsyncReadTimeStampedValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>> PrepareAsyncReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>>(PrepareAsyncReadTimeStampedValuesRaw(context, request, cq));
    }
    // / <summary>
    // / Read the data including timestamps from the subscription with the given id
    // / separated in task records.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the added and subscribed variables including timestamps separated
    // / in task records.
    // / The data values are returned in a static order and doesn't contain
    // / any type information. To figure out which value belongs to the added
    // / variable, it is necessary to call the related information function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
    // / As long as the subscription doesn't resubscribed with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
    // / and both, the read value data and information data, are in a static
    // / order.
    // / </para>
    // / <para>
    // / The number of returned value records depends on the count of tasks,
    // / the number of sampled data and the number of the given
    // / <paramref name="count" /> parameter.
    // / </para>
    // / <para>
    // / The structure how the values are returned is strictly defined:
    // / The first array (records) contains n arrays (task records) and where
    // / n depends on the number of tasks.
    // / The array from the second dimension (task records) contains n arrays
    // / (record), where n depends on the number of collected data, one data
    // / record per task cycle.
    // / The array from the third dimension (record) contains the plain
    // / values, starting with the timestamp.
    // / </para>
    // / <para>
    // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
    // / before the tasks initially have written the data.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / task A sampled 2 cycles
    // / task B sampled 1 cycles
    // /
    // / Results in:
    // / object[] (records)
    // / object[] (task A records)
    // / object[] (record cycle 1)
    // / timestamp
    // / a1
    // / a2
    // / object[] (record cycle 2)
    // / timestamp
    // / a1
    // / a2
    // / object[] (task B records)
    // / object[] (record cycle 1)
    // / timestamp
    // / a1
    // / a2
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="count">
    // / Number of maximum records to be copied per task. If set to zero, all available records
    // / will be copied.
    // / </param>
    // / <param name="records">
    // / Array for the subscribed data records including timestamps.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>> AsyncReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>>(AsyncReadRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>> PrepareAsyncReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>>(PrepareAsyncReadRecordsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // / <summary>
      // / Creates a subscription of the given <see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
      // / </summary>
      // / <remarks>
      // / <para>
      // / This method allows other components, also from remote targets,
      // / to create a subscription which is able to subscribe each PLC variable.
      // / On success it returns a unique <c>SubscriptionId</c> which is
      // / created internally. The <c>SubscriptionId</c> has to be exposed to the SDK
      // / user, due to the usage on remote targets. The <c>SubscriptionId</c> is
      // / the reference to a created subscription at the PLC target and is needed in
      // / each subscription method exclude this and <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
      // / </para>
      // / <para>
      // / Each subscription contains at least one buffer which kind depends on the
      // / <see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
      // / tasks which contains the added variables. The buffer are initialized with a
      // / <see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
      // / Apart from <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
      // / the task. How often the task stores the data to the buffer depends on the task
      // / cycle time and the configured subscription sample interval.
      // / </para>
      // / <para>
      // / The <see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
      // / created. Each kind has its own benefits and differs in consistence, performance and
      // / memory usage. The available kinds are listed below:
      // / </para>
      // / <list type="table">
      // / <listheader>
      // / <term>kind</term>
      // / <description>description</description>
      // / </listheader>
      // / <item>
      // / <term>
      // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
      // / </term>
      // / <description>
      // / The subscription itself triggers the copy process and will read the data
      // / directly from the source. This could be the fastest way and with no
      // / influence to the real time, to get the current data, but
      // / the task consistency is not guaranteed.
      // / <para>
      // / Usage example: Asynchronous data collection for non critical data.
      // / </para></description>
      // / </item>
      // / <item>
      // / <term>
      // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
      // / </term>
      // / <description>
      // / This subscription uses a <c>DoubleBuffer</c> which contains the last
      // / written data from the added variables. This kind is task consistent, has low
      // / influence to the real time and is low in memory usage.
      // / <para>
      // / Usage example: Standard way to collect the variable data.
      // / </para></description>
      // / </item>
      // / <item>
      // / <term>
      // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
      // / </term>
      // / <description>
      // / This subscription uses a <c>QuadBuffer</c> which contains the last
      // / written data from the added variables. This kind is task consistent, has the
      // / fastest access to the current written data, but uses the fourfold memory.
      // / <para>
      // / Usage example: For variables which are running in high speed tasks and for which
      // / it is necessary to guarantee the fastest access to the current written data.
      // / Note that in most cases the <see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
      // / sufficient.
      // / </para></description>
      // / </item>
      // / <item>
      // / <term>
      // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
      // / </term>
      // / <description>
      // / This subscription uses a <c>RingBuffer</c> which is able to store
      // / more than one record of data. This kind is task consistent, has low
      // / influence to the real time, but needs, dependent to the ring capacity, a lot
      // / of memory. By default the ring capacity is <c>10</c>, use
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
      // / witch a self defined size.
      // / <para>
      // / Usage example: For variables which are running in faster tasks than the consumer does
      // / and for which it is necessary to guarantee that every data record will be stored,
      // / without a single gap.
      // / Note that this kind uses a lot of memory!
      // / </para></description>
      // / </item>
      // / </list>
      // / <para>
      // / After the subscription is created successfully, variables could be added with
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      // / with the <c>SubscriptionId</c> just returned in this method.
      // / </para>
      // / </remarks>
      // / <param name="kind">
      // / The kind of the subscription.
      // / </param>
      // / <returns>
      // / The unique subscription id on success, otherwise 0.
      // / <para></para></returns>
      virtual void CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Creates a subscription of <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      // / </summary>
      // / <remarks>
      // / This method creates a subscription of the kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
      // / Compared to the method <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
      // / configure the capacity of the internal used ring buffer.
      // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
      // / </remarks>
      // / <param name="recordCount">
      // / The maximum number of storable records.
      // / </param>
      // / <returns>
      // / The unique subscription id on success, otherwise 0.
      // / </returns>
      // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
      virtual void CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Extends the subscription with the given id by inserting the given
      // / variable name
      // / </summary>
      // / <remarks>
      // / <para>
      // / The added variable is stored in a internal container and will be
      // / subscribed after calling <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
      // / the subscription has already been subscribed, it is necessary to
      // / call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
      // / added variable finally.
      // / </para>
      // / <para>
      // / If the same full variable name is added multiple times, the old variable will be
      // / overridden. In case, a variable name is invalid or doesn't exists
      // / a specific error code will be returned <see cref="Arp.Device.Interface.Services.DataAccessError" />,
      // / on success the code <see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      // / of the added variable will be returned. A variable which doesn't returned with
      // / <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
      // / and won't be subscribed.
      // / </para>
      // / <para>
      // / A single array element can added with its index in brackets e.g.:
      // / <code>
      // / ComponentName-1/ProgramName-1.Array_Name[index]
      // / </code>
      // /
      // / Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
      // / <code>
      // / ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
      // / </code>
      // /
      // / If an array variable is added without a variable specification,
      // / the entire array will be added to the subscription.
      // / </para>
      // / <para>
      // / An alternative way to insert variables to the subscription is by using
      // / the function <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
      // / </para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription where the variable is add to.
      // / </param>
      // / <param name="variableName">
      // / The full name of the variable.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
      virtual void AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Extends the subscription with the given id by inserting a range of new variables.
      // / </summary>
      // / <remarks>
      // / Allows to add a range of variables to the subscription. The returned array of type <see cref="Arp.Device.Interface.Services.DataAccessError" />,
      // / is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
      // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription where the variables are added to.
      // / </param>
      // / <param name="variableNames">
      // / An array of full variable names.
      // / </param>
      // / <returns>
      // / Returns a vector of <see cref="Arp.Device.Interface.Services.DataAccessError" />, <see cref="Arp.Device.Interface.Services.DataAccessError.None" />
      // / on success, in the same order as the variables were added.
      // / </returns>
      // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
      virtual void AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Removes the variable with the specific variable name from the subscription.
      // / </summary>
      // / <remarks>
      // / Removes the variable that compare equal to the given variable name, from the
      // / internal variable list. If the subscription has already been subscribed,
      // / it is necessary to call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
      // / remove the given variable from the internal created buffer.
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="variableName">
      // / The full name of the variable to be removed from the subscription.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Subscribes the subscription with the given id.
      // / </summary>
      // / <remarks>
      // / <para>
      // / All previously added variables including in the given subscription will be subscribed. Internally
      // / the variables are separated in the respective tasks, a buffer for each task will be created and
      // / connected to the task executed event. At this point the task will copy the selected variable data
      // / into the task buffer (excluded subscriptions from kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
      // / How often the task stores the data to the buffer depends on the task cycle time and the
      // / configured subscription sample rate.
      // / </para>
      // / <para>
      // / Calling this method on a already subscribed subscription has no effect, even if new
      // / variables have been added or removed. To make variable modification effective, use
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
      // / <c>Unsubscribed</c>, because <see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
      // / connect the already constructed buffer to the respective tasks and will set the given sampleRate.
      // / Compare to the first and initial call of this method, this call cost more less time because
      // / the buffer are already created. This also means that variable modification which have been
      // / done after the first call of <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
      // / it is also necessary to call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
      // / </para>
      // / <para>
      // / A subscribed subscription can operates in different sample rates (excluded subscriptions from
      // / kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
      // / First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
      // / the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
      // / task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
      // / Thats the case if the given sample rate is set to zero,
      // / which means the subscription operates in <c>'real-time'</c>, the same sample rate the task is operating in.
      // / This is also the fastest possible rate for a subscription.
      // / Note that it's possible that one subscription could contain variables from different tasks, which has the
      // / consequence that the subscription operates in different rates!
      // / If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
      // / no matter from which task this variable comes.
      // / Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
      // / the given rate will rounded down. E.g.:
      // /
      // / <code>
      // / Task A cycle rate = 10ms
      // / Task B cycle rate = 8ms
      // /
      // / Subscription given rate = 50ms
      // /
      // / Subscription rate for task A = 50ms
      // / Subscription rate for task B = 48ms
      // / </code>
      // /
      // / Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
      // / the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
      // / But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
      // / the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
      // / downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
      // / or an multiple of them.
      // / </para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="sampleRate">
      // / The desired sample rate in microseconds.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
      virtual void Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Resubscribes the subscription with the given id.
      // / </summary>
      // / <remarks>
      // / <para>
      // / Resubscribes the subscription, which will trigger a completely rebuild process of
      // / the whole subscription, including previously done variable modification which have been
      // / done after the first call of <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      // / It destroys the internal buffer and subscribes the subscription again
      // / (for further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
      // / Note that the subscription is not able to collect data from the variables, while the
      // / resubscribe process is in progress.
      // / </para>
      // / <para>
      // / This method has only an effect if the given subscription is currently subscribed,
      // / otherwise nothing will happen.
      // / </para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="sampleRate">
      // / The desired sample rate in microseconds.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
      virtual void Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Unsubscribes the subscription with the given id.
      // / </summary>
      // / <remarks>
      // / <para>
      // / Unsubscribes the subscription from all task executed events. The subscription
      // / data are still exist and could be get by the respective read-methods. To
      // / subscribe the subscription again, call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
      // / </para>
      // / <para>
      // / This method has only an effect if the given subscription is currently subscribed,
      // / otherwise nothing will happen.
      // / </para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Deletes the subscription.
      // / </summary>
      // / <remarks>
      // / Deletes the subscription with the given id. After that the id is no longer valid and all data,
      // / containing in the subscription will be removed.
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Get the subscribed variable information of the subscription.
      // / </summary>
      // / <remarks>
      // / <para>
      // / The subscription service provides several read functions
      // / (<see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
      // / return the plain values without any information of type and order.
      // / To assign this plain values to the added variables, this function returns
      // / the currently subscribed variable information in a array of
      // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
      // / This order and type information wont change, till
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
      // / Note that this order does not have to be the same order like the
      // / variables has been added to the subscription.
      // / </para>
      // / <para>
      // / This service function relates to the read function
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
      // / The provided information contains only information of the added and
      // / currently subscribed variables. It doesn't contain information
      // / of timestamps. Timestamps could be read by the function
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
      // / information with <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      // / </para>
      // / <para>
      // / Example:
      // / <code>
      // / Added Variable from task A: a1, a2
      // / Added Variable from task B: b1
      // /
      // / Results in:
      // / VariableInfo[]
      // / a1
      // / a2
      // / b1
      // / </code></para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="variableInfo">
      // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
      // / timestamp information.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Get the subscribed variable information including information
      // / of timestamps of the subscription.
      // / </summary>
      // / <remarks>
      // / <para>
      // / This service function relates to the read function
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
      // / The provided information contains information of the added and
      // / currently subscribed variables and additionally information about the
      // / timestamps. Note that a subscription could contain multiple
      // / timestamps, related on the number of used tasks from which the
      // / added variables are from. The timestamp is always the first value
      // / followed by all to the task related variable information.
      // / </para>
      // / <para>
      // / Example:
      // / <code>
      // / Added Variable from task A: a1, a2
      // / Added Variable from task B: b1
      // /
      // / Results in:
      // / VariableInfo[]
      // / timestamp
      // / a1
      // / a2
      // / timestamp
      // / b1
      // / </code></para>
      // / <para>
      // / Each containing timestamp has the variable name <c>timestamp</c> and
      // / the data type <see cref="Arp.Plc.DataType.Int64" /> which is provided in
      // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      // / </para>
      // / <para>
      // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      // / </para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="variableInfo">
      // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" />.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Get the subscribed variable information as a record of the subscription.
      // / </summary>
      // / <remarks>
      // / <para>
      // / This service function relates to the read function
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
      // / The provided information contains information of the added and
      // / currently subscribed variables, its task relation and additionally
      // / information about the task related timestamp.
      // / </para>
      // / <para>
      // / The information are provided in an array of array of
      // / <see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
      // / number of different tasks and the second contains the related variable
      // / information which are related to the variables of this task and
      // / additionally information about the task related timestamp.
      // / </para>
      // / <para>
      // / Each containing timestamp has the variable name <c>timestamp</c> and
      // / the data type <see cref="Arp.Plc.DataType.Int64" /> which is provided in
      // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
      // / </para>
      // / <para>
      // / Example:
      // / <code>
      // / Added Variable from task A: a1, a2
      // / Added Variable from task B: b1
      // /
      // / Results in:
      // / VariableInfo[][]
      // / VariableInfo[]
      // / timestamp
      // / a1
      // / a2
      // / VariableInfo[]
      // / timestamp
      // / b1
      // / </code></para>
      // / <para>
      // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      // / </para>
      // / <para>
      // / Note: This function is currently not supported in C#!.
      // / </para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="recordInfos">
      // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" />.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Read the data from the subscription with the given id.
      // / </summary>
      // / <remarks>
      // / <para>
      // / This service function returns the plain data values from
      // / the added and subscribed variables. The data values are returned
      // / in a static order and doesn't contain any type information. To
      // / figure out which value belongs to the added variable, it is necessary
      // / to call the related information function
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
      // / As long as the subscription doesn't resubscribed with
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      // / and both, the read value data and information data, are in a static
      // / order.
      // / </para>
      // / <para>
      // / Note that this values doesn't contain timestamps! If the timestamp is
      // / needed use the function <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
      // / instead.
      // / </para>
      // / <para>
      // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      // / before the tasks initially have written the data.
      // / </para>
      // / <para>
      // / Example:
      // / <code>
      // / Added Variable from task A: a1, a2
      // / Added Variable from task B: b1
      // /
      // / Results in:
      // / object[]
      // / a1
      // / a2
      // / b1
      // / </code></para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="values">
      // / Contains the plain values of the given and subscribed variables.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Read the data including timestamps from the subscription with the given id.
      // / </summary>
      // / <remarks>
      // / <para>
      // / This service function returns the plain data values from
      // / the added and subscribed variables including timestamps.
      // / The data values are returned in a static order and doesn't contain
      // / any type information. To figure out which value belongs to the added
      // / variable, it is necessary to call the related information function
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
      // / As long as the subscription doesn't resubscribed with
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      // / and both, the read value data and information data, are in a static
      // / order.
      // / </para>
      // / <para>
      // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      // / before the tasks initially have written the data.
      // / </para>
      // / <para>
      // / Example:
      // / <code>
      // / Added Variable from task A: a1, a2
      // / Added Variable from task B: b1
      // /
      // / Results in:
      // / object[]
      // / timestamp task A
      // / a1
      // / a2
      // / timestamp task B
      // / b1
      // / </code></para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="values">
      // / Contains the plain values including the timestamps of the
      // / given and subscribed variables.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // / <summary>
      // / Read the data including timestamps from the subscription with the given id
      // / separated in task records.
      // / </summary>
      // / <remarks>
      // / <para>
      // / This service function returns the plain data values from
      // / the added and subscribed variables including timestamps separated
      // / in task records.
      // / The data values are returned in a static order and doesn't contain
      // / any type information. To figure out which value belongs to the added
      // / variable, it is necessary to call the related information function
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
      // / As long as the subscription doesn't resubscribed with
      // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
      // / and both, the read value data and information data, are in a static
      // / order.
      // / </para>
      // / <para>
      // / The number of returned value records depends on the count of tasks,
      // / the number of sampled data and the number of the given
      // / <paramref name="count" /> parameter.
      // / </para>
      // / <para>
      // / The structure how the values are returned is strictly defined:
      // / The first array (records) contains n arrays (task records) and where
      // / n depends on the number of tasks.
      // / The array from the second dimension (task records) contains n arrays
      // / (record), where n depends on the number of collected data, one data
      // / record per task cycle.
      // / The array from the third dimension (record) contains the plain
      // / values, starting with the timestamp.
      // / </para>
      // / <para>
      // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
      // / before the tasks initially have written the data.
      // / </para>
      // / <para>
      // / Example:
      // / <code>
      // / Added Variable from task A: a1, a2
      // / Added Variable from task B: b1
      // /
      // / task A sampled 2 cycles
      // / task B sampled 1 cycles
      // /
      // / Results in:
      // / object[] (records)
      // / object[] (task A records)
      // / object[] (record cycle 1)
      // / timestamp
      // / a1
      // / a2
      // / object[] (record cycle 2)
      // / timestamp
      // / a1
      // / a2
      // / object[] (task B records)
      // / object[] (record cycle 1)
      // / timestamp
      // / a1
      // / a2
      // / </code></para>
      // / </remarks>
      // / <param name="subscriptionId">
      // / The id of the subscription.
      // / </param>
      // / <param name="count">
      // / Number of maximum records to be copied per task. If set to zero, all available records
      // / will be copied.
      // / </param>
      // / <param name="records">
      // / Array for the subscribed data records including timestamps.
      // / </param>
      // / <returns>
      // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
      // / </returns>
      virtual void ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* AsyncCreateSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* PrepareAsyncCreateSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* AsyncCreateRecordingSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* PrepareAsyncCreateRecordingSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* AsyncAddVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* PrepareAsyncAddVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* AsyncAddVariablesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* PrepareAsyncAddVariablesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* AsyncRemoveVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* PrepareAsyncRemoveVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* AsyncResubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* PrepareAsyncResubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* AsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* PrepareAsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* AsyncDeleteSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* PrepareAsyncDeleteSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* AsyncGetVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* PrepareAsyncGetVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* AsyncGetTimeStampedVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* PrepareAsyncGetTimeStampedVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* AsyncGetRecordInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* PrepareAsyncGetRecordInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* AsyncReadValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* PrepareAsyncReadValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* AsyncReadTimeStampedValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* PrepareAsyncReadTimeStampedValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* AsyncReadRecordsRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* PrepareAsyncReadRecordsRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>> AsyncCreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>>(AsyncCreateSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>> PrepareAsyncCreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>>(PrepareAsyncCreateSubscriptionRaw(context, request, cq));
    }
    ::grpc::Status CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>> AsyncCreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>>(AsyncCreateRecordingSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>> PrepareAsyncCreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>>(PrepareAsyncCreateRecordingSubscriptionRaw(context, request, cq));
    }
    ::grpc::Status AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>> AsyncAddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>>(AsyncAddVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>> PrepareAsyncAddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>>(PrepareAsyncAddVariableRaw(context, request, cq));
    }
    ::grpc::Status AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>> AsyncAddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>>(AsyncAddVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>> PrepareAsyncAddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>>(PrepareAsyncAddVariablesRaw(context, request, cq));
    }
    ::grpc::Status RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>> AsyncRemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>>(AsyncRemoveVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>> PrepareAsyncRemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>>(PrepareAsyncRemoveVariableRaw(context, request, cq));
    }
    ::grpc::Status Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>> AsyncSubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>>(AsyncSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>> PrepareAsyncSubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>>(PrepareAsyncSubscribeRaw(context, request, cq));
    }
    ::grpc::Status Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>> AsyncResubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>>(AsyncResubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>> PrepareAsyncResubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>>(PrepareAsyncResubscribeRaw(context, request, cq));
    }
    ::grpc::Status Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>> AsyncUnsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>>(AsyncUnsubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>> PrepareAsyncUnsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>>(PrepareAsyncUnsubscribeRaw(context, request, cq));
    }
    ::grpc::Status DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>> AsyncDeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>>(AsyncDeleteSubscriptionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>> PrepareAsyncDeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>>(PrepareAsyncDeleteSubscriptionRaw(context, request, cq));
    }
    ::grpc::Status GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>> AsyncGetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>>(AsyncGetVariableInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>> PrepareAsyncGetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>>(PrepareAsyncGetVariableInfosRaw(context, request, cq));
    }
    ::grpc::Status GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>> AsyncGetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>>(AsyncGetTimeStampedVariableInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>> PrepareAsyncGetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>>(PrepareAsyncGetTimeStampedVariableInfosRaw(context, request, cq));
    }
    ::grpc::Status GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>> AsyncGetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>>(AsyncGetRecordInfosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>> PrepareAsyncGetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>>(PrepareAsyncGetRecordInfosRaw(context, request, cq));
    }
    ::grpc::Status ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>> AsyncReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>>(AsyncReadValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>> PrepareAsyncReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>>(PrepareAsyncReadValuesRaw(context, request, cq));
    }
    ::grpc::Status ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>> AsyncReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>>(AsyncReadTimeStampedValuesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>> PrepareAsyncReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>>(PrepareAsyncReadTimeStampedValuesRaw(context, request, cq));
    }
    ::grpc::Status ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>> AsyncReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>>(AsyncReadRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>> PrepareAsyncReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>>(PrepareAsyncReadRecordsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateRecordingSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddVariables(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RemoveVariable(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Subscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Resubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Unsubscribe(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteSubscription(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTimeStampedVariableInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRecordInfos(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadTimeStampedValues(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadRecords(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* AsyncCreateSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* PrepareAsyncCreateSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* AsyncCreateRecordingSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* PrepareAsyncCreateRecordingSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* AsyncAddVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* PrepareAsyncAddVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* AsyncAddVariablesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* PrepareAsyncAddVariablesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* AsyncRemoveVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* PrepareAsyncRemoveVariableRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* AsyncSubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* PrepareAsyncSubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* AsyncResubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* PrepareAsyncResubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* AsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* PrepareAsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* AsyncDeleteSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* PrepareAsyncDeleteSubscriptionRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* AsyncGetVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* PrepareAsyncGetVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* AsyncGetTimeStampedVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* PrepareAsyncGetTimeStampedVariableInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* AsyncGetRecordInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* PrepareAsyncGetRecordInfosRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* AsyncReadValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* PrepareAsyncReadValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* AsyncReadTimeStampedValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* PrepareAsyncReadTimeStampedValuesRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* AsyncReadRecordsRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* PrepareAsyncReadRecordsRaw(::grpc::ClientContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateSubscription_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateRecordingSubscription_;
    const ::grpc::internal::RpcMethod rpcmethod_AddVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_AddVariables_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_Subscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_Resubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_Unsubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteSubscription_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVariableInfos_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTimeStampedVariableInfos_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRecordInfos_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadValues_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadTimeStampedValues_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadRecords_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / <summary>
    // / Creates a subscription of the given <see cref="Arp.Device.Interface.Services.SubscriptionKind" />.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This method allows other components, also from remote targets,
    // / to create a subscription which is able to subscribe each PLC variable.
    // / On success it returns a unique <c>SubscriptionId</c> which is
    // / created internally. The <c>SubscriptionId</c> has to be exposed to the SDK
    // / user, due to the usage on remote targets. The <c>SubscriptionId</c> is
    // / the reference to a created subscription at the PLC target and is needed in
    // / each subscription method exclude this and <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" />.
    // / </para>
    // / <para>
    // / Each subscription contains at least one buffer which kind depends on the
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind" />. The number of buffer depends on the different
    // / tasks which contains the added variables. The buffer are initialized with a
    // / <see cref="Arp.Plc.DataType" /> specific initial value e.g.: int8 = 0 or boolean = false.
    // / Apart from <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />, the buffer will filled by
    // / the task. How often the task stores the data to the buffer depends on the task
    // / cycle time and the configured subscription sample interval.
    // / </para>
    // / <para>
    // / The <see cref="Arp.Device.Interface.Services.SubscriptionKind" /> decides which kind of a subscription will be
    // / created. Each kind has its own benefits and differs in consistence, performance and
    // / memory usage. The available kinds are listed below:
    // / </para>
    // / <list type="table">
    // / <listheader>
    // / <term>kind</term>
    // / <description>description</description>
    // / </listheader>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />
    // / </term>
    // / <description>
    // / The subscription itself triggers the copy process and will read the data
    // / directly from the source. This could be the fastest way and with no
    // / influence to the real time, to get the current data, but
    // / the task consistency is not guaranteed.
    // / <para>
    // / Usage example: Asynchronous data collection for non critical data.
    // / </para></description>
    // / </item>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" />
    // / </term>
    // / <description>
    // / This subscription uses a <c>DoubleBuffer</c> which contains the last
    // / written data from the added variables. This kind is task consistent, has low
    // / influence to the real time and is low in memory usage.
    // / <para>
    // / Usage example: Standard way to collect the variable data.
    // / </para></description>
    // / </item>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.RealTime" />
    // / </term>
    // / <description>
    // / This subscription uses a <c>QuadBuffer</c> which contains the last
    // / written data from the added variables. This kind is task consistent, has the
    // / fastest access to the current written data, but uses the fourfold memory.
    // / <para>
    // / Usage example: For variables which are running in high speed tasks and for which
    // / it is necessary to guarantee the fastest access to the current written data.
    // / Note that in most cases the <see cref="Arp.Device.Interface.Services.SubscriptionKind.HighPerformance" /> is
    // / sufficient.
    // / </para></description>
    // / </item>
    // / <item>
    // / <term>
    // / <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />
    // / </term>
    // / <description>
    // / This subscription uses a <c>RingBuffer</c> which is able to store
    // / more than one record of data. This kind is task consistent, has low
    // / influence to the real time, but needs, dependent to the ring capacity, a lot
    // / of memory. By default the ring capacity is <c>10</c>, use
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateRecordingSubscription" /> to create a subscription
    // / witch a self defined size.
    // / <para>
    // / Usage example: For variables which are running in faster tasks than the consumer does
    // / and for which it is necessary to guarantee that every data record will be stored,
    // / without a single gap.
    // / Note that this kind uses a lot of memory!
    // / </para></description>
    // / </item>
    // / </list>
    // / <para>
    // / After the subscription is created successfully, variables could be added with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" /> or <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
    // / with the <c>SubscriptionId</c> just returned in this method.
    // / </para>
    // / </remarks>
    // / <param name="kind">
    // / The kind of the subscription.
    // / </param>
    // / <returns>
    // / The unique subscription id on success, otherwise 0.
    // / <para></para></returns>
    virtual ::grpc::Status CreateSubscription(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response);
    // / <summary>
    // / Creates a subscription of <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
    // / </summary>
    // / <remarks>
    // / This method creates a subscription of the kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.Recording" />.
    // / Compared to the method <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />, it allows to
    // / configure the capacity of the internal used ring buffer.
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />.
    // / </remarks>
    // / <param name="recordCount">
    // / The maximum number of storable records.
    // / </param>
    // / <returns>
    // / The unique subscription id on success, otherwise 0.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.CreateSubscription" />
    virtual ::grpc::Status CreateRecordingSubscription(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response);
    // / <summary>
    // / Extends the subscription with the given id by inserting the given
    // / variable name
    // / </summary>
    // / <remarks>
    // / <para>
    // / The added variable is stored in a internal container and will be
    // / subscribed after calling <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />. If
    // / the subscription has already been subscribed, it is necessary to
    // / call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to subscribe the new
    // / added variable finally.
    // / </para>
    // / <para>
    // / If the same full variable name is added multiple times, the old variable will be
    // / overridden. In case, a variable name is invalid or doesn't exists
    // / a specific error code will be returned <see cref="Arp.Device.Interface.Services.DataAccessError" />,
    // / on success the code <see cref="Arp.Device.Interface.Services.DataAccessError.None" />
    // / of the added variable will be returned. A variable which doesn't returned with
    // / <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> won't be added to the subscription
    // / and won't be subscribed.
    // / </para>
    // / <para>
    // / A single array element can added with its index in brackets e.g.:
    // / <code>
    // / ComponentName-1/ProgramName-1.Array_Name[index]
    // / </code>
    // /
    // / Or a rage of an array can added with tow indexes separated with a colon in brackets e.g.:
    // / <code>
    // / ComponentName-1/ProgramName-1.Array_Name[StartIndex:EndIndex]
    // / </code>
    // /
    // / If an array variable is added without a variable specification,
    // / the entire array will be added to the subscription.
    // / </para>
    // / <para>
    // / An alternative way to insert variables to the subscription is by using
    // / the function <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription where the variable is add to.
    // / </param>
    // / <param name="variableName">
    // / The full name of the variable.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariables" />
    virtual ::grpc::Status AddVariable(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response);
    // / <summary>
    // / Extends the subscription with the given id by inserting a range of new variables.
    // / </summary>
    // / <remarks>
    // / Allows to add a range of variables to the subscription. The returned array of type <see cref="Arp.Device.Interface.Services.DataAccessError" />,
    // / is in the same order as the given array of variable names and indicates if the given variables are valid and exist.
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />.
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription where the variables are added to.
    // / </param>
    // / <param name="variableNames">
    // / An array of full variable names.
    // / </param>
    // / <returns>
    // / Returns a vector of <see cref="Arp.Device.Interface.Services.DataAccessError" />, <see cref="Arp.Device.Interface.Services.DataAccessError.None" />
    // / on success, in the same order as the variables were added.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.AddVariable" />
    virtual ::grpc::Status AddVariables(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response);
    // / <summary>
    // / Removes the variable with the specific variable name from the subscription.
    // / </summary>
    // / <remarks>
    // / Removes the variable that compare equal to the given variable name, from the
    // / internal variable list. If the subscription has already been subscribed,
    // / it is necessary to call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> to
    // / remove the given variable from the internal created buffer.
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="variableName">
    // / The full name of the variable to be removed from the subscription.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status RemoveVariable(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response);
    // / <summary>
    // / Subscribes the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / All previously added variables including in the given subscription will be subscribed. Internally
    // / the variables are separated in the respective tasks, a buffer for each task will be created and
    // / connected to the task executed event. At this point the task will copy the selected variable data
    // / into the task buffer (excluded subscriptions from kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />).
    // / How often the task stores the data to the buffer depends on the task cycle time and the
    // / configured subscription sample rate.
    // / </para>
    // / <para>
    // / Calling this method on a already subscribed subscription has no effect, even if new
    // / variables have been added or removed. To make variable modification effective, use
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />. Calling this method while the subscription is in the state
    // / <c>Unsubscribed</c>, because <see cref="Arp.Device.Interface.Services.ISubscriptionService.Unsubscribe" /> has been called, will only
    // / connect the already constructed buffer to the respective tasks and will set the given sampleRate.
    // / Compare to the first and initial call of this method, this call cost more less time because
    // / the buffer are already created. This also means that variable modification which have been
    // / done after the first call of <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />, have also no effect. At this point
    // / it is also necessary to call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />.
    // / </para>
    // / <para>
    // / A subscribed subscription can operates in different sample rates (excluded subscriptions from
    // / kind <see cref="Arp.Device.Interface.Services.SubscriptionKind.DirectRead" />) which depends on several factors.
    // / First, each variable belongs to a program which runs in a task and this task has a cycle rate which determines
    // / the sample rate. This means that at the end of each task cycle, all variable data, subscribed and related to this
    // / task, will be written to the corresponding buffer. Note that all global variables are assigned to the task 'Globals'.
    // / Thats the case if the given sample rate is set to zero,
    // / which means the subscription operates in <c>'real-time'</c>, the same sample rate the task is operating in.
    // / This is also the fastest possible rate for a subscription.
    // / Note that it's possible that one subscription could contain variables from different tasks, which has the
    // / consequence that the subscription operates in different rates!
    // / If the given sample rate desire to a specific rate, the subscription tries to operate in this rate, for each variable,
    // / no matter from which task this variable comes.
    // / Potential self defined sample rates for a subscription are the task cycle rate or a multiple of them, otherwise
    // / the given rate will rounded down. E.g.:
    // /
    // / <code>
    // / Task A cycle rate = 10ms
    // / Task B cycle rate = 8ms
    // /
    // / Subscription given rate = 50ms
    // /
    // / Subscription rate for task A = 50ms
    // / Subscription rate for task B = 48ms
    // / </code>
    // /
    // / Special handling for global Varibales: If there isn't a given sample rate by the user (value is zero),
    // / the global variables will be recored by default from the 'Globals' task (50ms, configured in the ESM.config).
    // / But if there is a given sample rate (value is greater than zero) the global variables will be connected a task which fits
    // / the given sample rate. If no task exists with the given sample rate, the fastest available task will be picked and used for
    // / downsampling (see above). So it is possible to record data of global variables in the fastest availble interval
    // / or an multiple of them.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="sampleRate">
    // / The desired sample rate in microseconds.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />
    virtual ::grpc::Status Subscribe(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response);
    // / <summary>
    // / Resubscribes the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / Resubscribes the subscription, which will trigger a completely rebuild process of
    // / the whole subscription, including previously done variable modification which have been
    // / done after the first call of <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
    // / It destroys the internal buffer and subscribes the subscription again
    // / (for further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />).
    // / Note that the subscription is not able to collect data from the variables, while the
    // / resubscribe process is in progress.
    // / </para>
    // / <para>
    // / This method has only an effect if the given subscription is currently subscribed,
    // / otherwise nothing will happen.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="sampleRate">
    // / The desired sample rate in microseconds.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    // / <seealso cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />
    virtual ::grpc::Status Resubscribe(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response);
    // / <summary>
    // / Unsubscribes the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / Unsubscribes the subscription from all task executed events. The subscription
    // / data are still exist and could be get by the respective read-methods. To
    // / subscribe the subscription again, call <see cref="Arp.Device.Interface.Services.ISubscriptionService.Subscribe" />.
    // / </para>
    // / <para>
    // / This method has only an effect if the given subscription is currently subscribed,
    // / otherwise nothing will happen.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status Unsubscribe(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response);
    // / <summary>
    // / Deletes the subscription.
    // / </summary>
    // / <remarks>
    // / Deletes the subscription with the given id. After that the id is no longer valid and all data,
    // / containing in the subscription will be removed.
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status DeleteSubscription(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response);
    // / <summary>
    // / Get the subscribed variable information of the subscription.
    // / </summary>
    // / <remarks>
    // / <para>
    // / The subscription service provides several read functions
    // / (<see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />,
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />) which will
    // / return the plain values without any information of type and order.
    // / To assign this plain values to the added variables, this function returns
    // / the currently subscribed variable information in a array of
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> in the same order as the read functions will do.
    // / This order and type information wont change, till
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" /> was called.
    // / Note that this order does not have to be the same order like the
    // / variables has been added to the subscription.
    // / </para>
    // / <para>
    // / This service function relates to the read function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadValues" />.
    // / The provided information contains only information of the added and
    // / currently subscribed variables. It doesn't contain information
    // / of timestamps. Timestamps could be read by the function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" /> and its related
    // / information with <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / VariableInfo[]
    // / a1
    // / a2
    // / b1
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="variableInfo">
    // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" /> in a static order without
    // / timestamp information.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status GetVariableInfos(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response);
    // / <summary>
    // / Get the subscribed variable information including information
    // / of timestamps of the subscription.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function relates to the read function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />.
    // / The provided information contains information of the added and
    // / currently subscribed variables and additionally information about the
    // / timestamps. Note that a subscription could contain multiple
    // / timestamps, related on the number of used tasks from which the
    // / added variables are from. The timestamp is always the first value
    // / followed by all to the task related variable information.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / VariableInfo[]
    // / timestamp
    // / a1
    // / a2
    // / timestamp
    // / b1
    // / </code></para>
    // / <para>
    // / Each containing timestamp has the variable name <c>timestamp</c> and
    // / the data type <see cref="Arp.Plc.DataType.Int64" /> which is provided in
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
    // / </para>
    // / <para>
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="variableInfo">
    // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" />.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status GetTimeStampedVariableInfos(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response);
    // / <summary>
    // / Get the subscribed variable information as a record of the subscription.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function relates to the read function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadRecords" />.
    // / The provided information contains information of the added and
    // / currently subscribed variables, its task relation and additionally
    // / information about the task related timestamp.
    // / </para>
    // / <para>
    // / The information are provided in an array of array of
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" />. The first array correspond to the
    // / number of different tasks and the second contains the related variable
    // / information which are related to the variables of this task and
    // / additionally information about the task related timestamp.
    // / </para>
    // / <para>
    // / Each containing timestamp has the variable name <c>timestamp</c> and
    // / the data type <see cref="Arp.Plc.DataType.Int64" /> which is provided in
    // / <see cref="Arp.Device.Interface.Services.VariableInfo" /> like each other variable information.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / VariableInfo[][]
    // / VariableInfo[]
    // / timestamp
    // / a1
    // / a2
    // / VariableInfo[]
    // / timestamp
    // / b1
    // / </code></para>
    // / <para>
    // / For further information see <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
    // / </para>
    // / <para>
    // / Note: This function is currently not supported in C#!.
    // / </para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="recordInfos">
    // / An array of <see cref="Arp.Device.Interface.Services.VariableInfo" />.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status GetRecordInfos(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response);
    // / <summary>
    // / Read the data from the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the added and subscribed variables. The data values are returned
    // / in a static order and doesn't contain any type information. To
    // / figure out which value belongs to the added variable, it is necessary
    // / to call the related information function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetVariableInfos" />.
    // / As long as the subscription doesn't resubscribed with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
    // / and both, the read value data and information data, are in a static
    // / order.
    // / </para>
    // / <para>
    // / Note that this values doesn't contain timestamps! If the timestamp is
    // / needed use the function <see cref="Arp.Device.Interface.Services.ISubscriptionService.ReadTimeStampedValues" />
    // / instead.
    // / </para>
    // / <para>
    // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
    // / before the tasks initially have written the data.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / object[]
    // / a1
    // / a2
    // / b1
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="values">
    // / Contains the plain values of the given and subscribed variables.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status ReadValues(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response);
    // / <summary>
    // / Read the data including timestamps from the subscription with the given id.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the added and subscribed variables including timestamps.
    // / The data values are returned in a static order and doesn't contain
    // / any type information. To figure out which value belongs to the added
    // / variable, it is necessary to call the related information function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetTimeStampedVariableInfos" />.
    // / As long as the subscription doesn't resubscribed with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
    // / and both, the read value data and information data, are in a static
    // / order.
    // / </para>
    // / <para>
    // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
    // / before the tasks initially have written the data.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / Results in:
    // / object[]
    // / timestamp task A
    // / a1
    // / a2
    // / timestamp task B
    // / b1
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="values">
    // / Contains the plain values including the timestamps of the
    // / given and subscribed variables.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status ReadTimeStampedValues(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response);
    // / <summary>
    // / Read the data including timestamps from the subscription with the given id
    // / separated in task records.
    // / </summary>
    // / <remarks>
    // / <para>
    // / This service function returns the plain data values from
    // / the added and subscribed variables including timestamps separated
    // / in task records.
    // / The data values are returned in a static order and doesn't contain
    // / any type information. To figure out which value belongs to the added
    // / variable, it is necessary to call the related information function
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.GetRecordInfos" />.
    // / As long as the subscription doesn't resubscribed with
    // / <see cref="Arp.Device.Interface.Services.ISubscriptionService.Resubscribe" />, all the information are valid
    // / and both, the read value data and information data, are in a static
    // / order.
    // / </para>
    // / <para>
    // / The number of returned value records depends on the count of tasks,
    // / the number of sampled data and the number of the given
    // / <paramref name="count" /> parameter.
    // / </para>
    // / <para>
    // / The structure how the values are returned is strictly defined:
    // / The first array (records) contains n arrays (task records) and where
    // / n depends on the number of tasks.
    // / The array from the second dimension (task records) contains n arrays
    // / (record), where n depends on the number of collected data, one data
    // / record per task cycle.
    // / The array from the third dimension (record) contains the plain
    // / values, starting with the timestamp.
    // / </para>
    // / <para>
    // / The read data may contain null values (<see cref="Arp.Plc.DataType.Void" />) if the read call was executed
    // / before the tasks initially have written the data.
    // / </para>
    // / <para>
    // / Example:
    // / <code>
    // / Added Variable from task A: a1, a2
    // / Added Variable from task B: b1
    // /
    // / task A sampled 2 cycles
    // / task B sampled 1 cycles
    // /
    // / Results in:
    // / object[] (records)
    // / object[] (task A records)
    // / object[] (record cycle 1)
    // / timestamp
    // / a1
    // / a2
    // / object[] (record cycle 2)
    // / timestamp
    // / a1
    // / a2
    // / object[] (task B records)
    // / object[] (record cycle 1)
    // / timestamp
    // / a1
    // / a2
    // / </code></para>
    // / </remarks>
    // / <param name="subscriptionId">
    // / The id of the subscription.
    // / </param>
    // / <param name="count">
    // / Number of maximum records to be copied per task. If set to zero, all available records
    // / will be copied.
    // / </param>
    // / <param name="records">
    // / Array for the subscribed data records including timestamps.
    // / </param>
    // / <returns>
    // / Returns <see cref="Arp.Device.Interface.Services.DataAccessError.None" /> on success.
    // / </returns>
    virtual ::grpc::Status ReadRecords(::grpc::ServerContext* context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateSubscription() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSubscription(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateRecordingSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateRecordingSubscription() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CreateRecordingSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRecordingSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRecordingSubscription(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddVariable() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_AddVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddVariable(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddVariables() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_AddVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariables(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddVariables(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveVariable() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_RemoveVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveVariable(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Subscribe() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Resubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Resubscribe() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Resubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResubscribe(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnsubscribe(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteSubscription() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_DeleteSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSubscription(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVariableInfos() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVariableInfos(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTimeStampedVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTimeStampedVariableInfos() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetTimeStampedVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTimeStampedVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTimeStampedVariableInfos(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRecordInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRecordInfos() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetRecordInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecordInfos(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadValues() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ReadValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadValues(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadTimeStampedValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadTimeStampedValues() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ReadTimeStampedValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTimeStampedValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadTimeStampedValues(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadRecords() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ReadRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadRecords(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadRecords(::grpc::ServerContext* context, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::grpc::ServerAsyncResponseWriter< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateSubscription<WithAsyncMethod_CreateRecordingSubscription<WithAsyncMethod_AddVariable<WithAsyncMethod_AddVariables<WithAsyncMethod_RemoveVariable<WithAsyncMethod_Subscribe<WithAsyncMethod_Resubscribe<WithAsyncMethod_Unsubscribe<WithAsyncMethod_DeleteSubscription<WithAsyncMethod_GetVariableInfos<WithAsyncMethod_GetTimeStampedVariableInfos<WithAsyncMethod_GetRecordInfos<WithAsyncMethod_ReadValues<WithAsyncMethod_ReadTimeStampedValues<WithAsyncMethod_ReadRecords<Service > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateSubscription() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* response) { return this->CreateSubscription(context, request, response); }));}
    void SetMessageAllocatorFor_CreateSubscription(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateSubscription(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateSubscription(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateRecordingSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateRecordingSubscription() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* response) { return this->CreateRecordingSubscription(context, request, response); }));}
    void SetMessageAllocatorFor_CreateRecordingSubscription(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateRecordingSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRecordingSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateRecordingSubscription(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateRecordingSubscription(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddVariable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* response) { return this->AddVariable(context, request, response); }));}
    void SetMessageAllocatorFor_AddVariable(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddVariable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddVariables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* response) { return this->AddVariables(context, request, response); }));}
    void SetMessageAllocatorFor_AddVariables(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariables(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddVariables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoveVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoveVariable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* response) { return this->RemoveVariable(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveVariable(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RemoveVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveVariable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Subscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* response) { return this->Subscribe(context, request, response); }));}
    void SetMessageAllocatorFor_Subscribe(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Subscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Resubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Resubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* response) { return this->Resubscribe(context, request, response); }));}
    void SetMessageAllocatorFor_Resubscribe(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Resubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Resubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Resubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Unsubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* response) { return this->Unsubscribe(context, request, response); }));}
    void SetMessageAllocatorFor_Unsubscribe(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Unsubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Unsubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteSubscription() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* response) { return this->DeleteSubscription(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteSubscription(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSubscription(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSubscription(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVariableInfos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* response) { return this->GetVariableInfos(context, request, response); }));}
    void SetMessageAllocatorFor_GetVariableInfos(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVariableInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVariableInfos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTimeStampedVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTimeStampedVariableInfos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* response) { return this->GetTimeStampedVariableInfos(context, request, response); }));}
    void SetMessageAllocatorFor_GetTimeStampedVariableInfos(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTimeStampedVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTimeStampedVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTimeStampedVariableInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTimeStampedVariableInfos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRecordInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRecordInfos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* response) { return this->GetRecordInfos(context, request, response); }));}
    void SetMessageAllocatorFor_GetRecordInfos(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRecordInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRecordInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRecordInfos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadValues() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* response) { return this->ReadValues(context, request, response); }));}
    void SetMessageAllocatorFor_ReadValues(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadValues(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadValues(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadTimeStampedValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadTimeStampedValues() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* response) { return this->ReadTimeStampedValues(context, request, response); }));}
    void SetMessageAllocatorFor_ReadTimeStampedValues(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadTimeStampedValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTimeStampedValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadTimeStampedValues(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadTimeStampedValues(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* request, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* response) { return this->ReadRecords(context, request, response); }));}
    void SetMessageAllocatorFor_ReadRecords(
        ::grpc::experimental::MessageAllocator< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadRecords(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_CreateSubscription<ExperimentalWithCallbackMethod_CreateRecordingSubscription<ExperimentalWithCallbackMethod_AddVariable<ExperimentalWithCallbackMethod_AddVariables<ExperimentalWithCallbackMethod_RemoveVariable<ExperimentalWithCallbackMethod_Subscribe<ExperimentalWithCallbackMethod_Resubscribe<ExperimentalWithCallbackMethod_Unsubscribe<ExperimentalWithCallbackMethod_DeleteSubscription<ExperimentalWithCallbackMethod_GetVariableInfos<ExperimentalWithCallbackMethod_GetTimeStampedVariableInfos<ExperimentalWithCallbackMethod_GetRecordInfos<ExperimentalWithCallbackMethod_ReadValues<ExperimentalWithCallbackMethod_ReadTimeStampedValues<ExperimentalWithCallbackMethod_ReadRecords<Service > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_CreateSubscription<ExperimentalWithCallbackMethod_CreateRecordingSubscription<ExperimentalWithCallbackMethod_AddVariable<ExperimentalWithCallbackMethod_AddVariables<ExperimentalWithCallbackMethod_RemoveVariable<ExperimentalWithCallbackMethod_Subscribe<ExperimentalWithCallbackMethod_Resubscribe<ExperimentalWithCallbackMethod_Unsubscribe<ExperimentalWithCallbackMethod_DeleteSubscription<ExperimentalWithCallbackMethod_GetVariableInfos<ExperimentalWithCallbackMethod_GetTimeStampedVariableInfos<ExperimentalWithCallbackMethod_GetRecordInfos<ExperimentalWithCallbackMethod_ReadValues<ExperimentalWithCallbackMethod_ReadTimeStampedValues<ExperimentalWithCallbackMethod_ReadRecords<Service > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateSubscription() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateRecordingSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateRecordingSubscription() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CreateRecordingSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRecordingSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddVariable() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_AddVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddVariables() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_AddVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariables(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveVariable() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_RemoveVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Subscribe() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Resubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Resubscribe() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Resubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteSubscription() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_DeleteSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVariableInfos() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTimeStampedVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTimeStampedVariableInfos() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetTimeStampedVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTimeStampedVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRecordInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRecordInfos() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetRecordInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadValues() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ReadValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadTimeStampedValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadTimeStampedValues() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ReadTimeStampedValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTimeStampedValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadRecords() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ReadRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadRecords(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateSubscription() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSubscription(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateRecordingSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateRecordingSubscription() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CreateRecordingSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRecordingSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRecordingSubscription(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddVariable() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_AddVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddVariables() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_AddVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariables(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddVariables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveVariable() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_RemoveVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Subscribe() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Resubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Resubscribe() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Resubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnsubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteSubscription() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_DeleteSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSubscription(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVariableInfos() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVariableInfos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTimeStampedVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTimeStampedVariableInfos() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetTimeStampedVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTimeStampedVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTimeStampedVariableInfos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRecordInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRecordInfos() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetRecordInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRecordInfos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadValues() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ReadValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadValues(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadTimeStampedValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadTimeStampedValues() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ReadTimeStampedValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTimeStampedValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadTimeStampedValues(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadRecords() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ReadRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadRecords(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateSubscription() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateSubscription(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateSubscription(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateSubscription(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateRecordingSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateRecordingSubscription() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateRecordingSubscription(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateRecordingSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRecordingSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateRecordingSubscription(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateRecordingSubscription(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddVariable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddVariable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddVariable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddVariables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddVariables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddVariables(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddVariables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoveVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoveVariable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveVariable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoveVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RemoveVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RemoveVariable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Subscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Subscribe(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Subscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Subscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Resubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Resubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Resubscribe(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Resubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Resubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Resubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Unsubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Unsubscribe(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Unsubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Unsubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteSubscription() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteSubscription(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSubscription(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSubscription(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVariableInfos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVariableInfos(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVariableInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVariableInfos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTimeStampedVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTimeStampedVariableInfos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTimeStampedVariableInfos(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTimeStampedVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTimeStampedVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTimeStampedVariableInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTimeStampedVariableInfos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRecordInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRecordInfos() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRecordInfos(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRecordInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRecordInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRecordInfos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRecordInfos(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadValues() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadValues(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadValues(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadValues(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadTimeStampedValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadTimeStampedValues() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadTimeStampedValues(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadTimeStampedValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadTimeStampedValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadTimeStampedValues(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadTimeStampedValues(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadRecords(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateSubscription() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* streamer) {
                       return this->StreamedCreateSubscription(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateSubscription(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateSubscriptionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateRecordingSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateRecordingSubscription() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* streamer) {
                       return this->StreamedCreateRecordingSubscription(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateRecordingSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateRecordingSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateRecordingSubscription(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceCreateRecordingSubscriptionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddVariable() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* streamer) {
                       return this->StreamedAddVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariableResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddVariables() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* streamer) {
                       return this->StreamedAddVariables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddVariables(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddVariables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceAddVariablesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveVariable() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* streamer) {
                       return this->StreamedRemoveVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveVariable(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceRemoveVariableResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Subscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Subscribe() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* streamer) {
                       return this->StreamedSubscribe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Subscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Subscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubscribe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceSubscribeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Resubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Resubscribe() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* streamer) {
                       return this->StreamedResubscribe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Resubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Resubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResubscribe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceResubscribeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* streamer) {
                       return this->StreamedUnsubscribe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnsubscribe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceUnsubscribeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteSubscription : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteSubscription() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* streamer) {
                       return this->StreamedDeleteSubscription(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteSubscription() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteSubscription(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteSubscription(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceDeleteSubscriptionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVariableInfos() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* streamer) {
                       return this->StreamedGetVariableInfos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVariableInfos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetVariableInfosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTimeStampedVariableInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTimeStampedVariableInfos() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* streamer) {
                       return this->StreamedGetTimeStampedVariableInfos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTimeStampedVariableInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTimeStampedVariableInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTimeStampedVariableInfos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetTimeStampedVariableInfosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRecordInfos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRecordInfos() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* streamer) {
                       return this->StreamedGetRecordInfos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRecordInfos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRecordInfos(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRecordInfos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceGetRecordInfosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadValues() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* streamer) {
                       return this->StreamedReadValues(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadValues(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadValuesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadTimeStampedValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadTimeStampedValues() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* streamer) {
                       return this->StreamedReadTimeStampedValues(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadTimeStampedValues() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadTimeStampedValues(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadTimeStampedValues(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadTimeStampedValuesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadRecords() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* streamer) {
                       return this->StreamedReadRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadRecords(::grpc::ServerContext* /*context*/, const ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest* /*request*/, ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsRequest,::Arp::Plc::Gds::Services::Grpc::ISubscriptionServiceReadRecordsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateSubscription<WithStreamedUnaryMethod_CreateRecordingSubscription<WithStreamedUnaryMethod_AddVariable<WithStreamedUnaryMethod_AddVariables<WithStreamedUnaryMethod_RemoveVariable<WithStreamedUnaryMethod_Subscribe<WithStreamedUnaryMethod_Resubscribe<WithStreamedUnaryMethod_Unsubscribe<WithStreamedUnaryMethod_DeleteSubscription<WithStreamedUnaryMethod_GetVariableInfos<WithStreamedUnaryMethod_GetTimeStampedVariableInfos<WithStreamedUnaryMethod_GetRecordInfos<WithStreamedUnaryMethod_ReadValues<WithStreamedUnaryMethod_ReadTimeStampedValues<WithStreamedUnaryMethod_ReadRecords<Service > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateSubscription<WithStreamedUnaryMethod_CreateRecordingSubscription<WithStreamedUnaryMethod_AddVariable<WithStreamedUnaryMethod_AddVariables<WithStreamedUnaryMethod_RemoveVariable<WithStreamedUnaryMethod_Subscribe<WithStreamedUnaryMethod_Resubscribe<WithStreamedUnaryMethod_Unsubscribe<WithStreamedUnaryMethod_DeleteSubscription<WithStreamedUnaryMethod_GetVariableInfos<WithStreamedUnaryMethod_GetTimeStampedVariableInfos<WithStreamedUnaryMethod_GetRecordInfos<WithStreamedUnaryMethod_ReadValues<WithStreamedUnaryMethod_ReadTimeStampedValues<WithStreamedUnaryMethod_ReadRecords<Service > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace Grpc
}  // namespace Services
}  // namespace Gds
}  // namespace Plc
}  // namespace Arp


#endif  // GRPC_ISubscriptionService_2eproto__INCLUDED
